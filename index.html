<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Arcade Games Online - Free Retro Games</title>
    <meta name="description" content="Explore classic arcade, puzzle, card, word, action, mini, and simulation/idle games online for free. Enjoy retro gaming with a nostalgic arcade vibe, optimized for desktop and mobile.">
    <meta name="keywords" content="classic arcade games, free retro games, puzzle games online, card games, word trivia games, action platform games, mini games, simulation games, idle games, arcade gaming website">
    <meta name="robots" content="index, follow">
    <meta name="author" content="Arcade Enthusiast">
    <link rel="canonical" href="https://www.classicarcadegames.com/">
    <meta property="og:title" content="Classic Arcade Games Online - Free Retro Games">
    <meta property="og:description" content="Discover a variety of classic arcade, puzzle, card, word, action, mini, and simulation/idle games for free in your browser.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.classicarcadegames.com/">
    <meta property="og:image" content="https://www.classicarcadegames.com/images/arcade-logo.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Classic Arcade Games Online">
    <meta name="twitter:description" content="Free online retro games across multiple genres.">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 0;
            text-align: center;
        }

        h1 {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            margin: 0;
            font-size: 1.8em;
        }

        main {
            padding: 30px;
            max-width: 900px;
            margin: 0 auto;
        }

        section {
            margin: 40px 0;
        }

        h2 {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        p {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            font-size: 0.9em;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        /* Card-like placeholder for games */
        .game-card {
            background-color: #222;
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff;
            padding: 15px;
            margin: 10px;
            display: inline-block;
            width: 200px;
            text-align: center;
            transition: transform 0.2s;
            vertical-align: top;
            cursor: pointer;
        }

        .game-card:hover {
            transform: scale(1.05);
        }

        .game-image {
            width: 100%;
            height: 150px;
            background-color: #333;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 5px #ff00ff;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            font-size: 0.7em;
        }

        .game-card span {
            color: #00ffff;
            font-size: 0.8em;
            text-shadow: 0 0 5px #00ffff;
            display: block;
        }

        /* Modal styles */

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #111;
            padding: 20px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 20px #ff00ff;
            max-width: 900px;
            width: 90%;
            text-align: center;
            position: relative;
        }

        .modal-content h3 {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
            font-size: 1em;
            margin: 10px 0;
        }

        .modal-content p {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            font-size: 0.8em;
        }

        .close {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #00ffff;
            font-size: 1.5em;
            cursor: pointer;
        }

        .close:hover {
            color: #ffff00;
        }

        /* Snake game styles within modal */
        #game-container {
            text-align: center;
        }

        #score {
            font-size: 0.9em;
            margin-bottom: 10px;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }

        #gameCanvas {
            border: 2px solid #00ffff;
            background-color: #222;
            box-shadow: 0 0 10px #00ffff;
        }

        #instructions {
            margin-top: 10px;
            font-size: 0.8em;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }

        #controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .d-pad {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .d-pad:nth-child(2) {
            flex-direction: row;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            background-color: #00ff00;
            color: #000;
            font-size: 0.8em;
            cursor: pointer;
            box-shadow: 0 4px #00cc00;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: none;
        }

        .control-btn:active {
            box-shadow: 0 2px #00cc00;
            transform: translateY(2px);
        }

        .control-btn:hover {
            background-color: #00cc00;
        }

        #pause-play-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 0.8em;
            cursor: pointer;
            background-color: #00ffff;
            color: #000;
            border: none;
            border-radius: 5px;
            box-shadow: 0 4px #00cccc;
            transition: all 0.1s;
            text-shadow: none;
        }

        #pause-play-btn:active {
            box-shadow: 0 2px #00cccc;
            transform: translateY(2px);
        }

        #pause-play-btn:hover {
            background-color: #00cccc;
        }

        #restart-btn {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 0.8em;
            cursor: pointer;
            background-color: #ff00ff;
            color: #000;
            border: none;
            border-radius: 5px;
            box-shadow: 0 4px #cc00cc;
            transition: all 0.1s;
            display: none;
            text-shadow: none;
        }

        #restart-btn:active {
            box-shadow: 0 2px #cc00cc;
            transform: translateY(2px);
        }

        #restart-btn:hover {
            background-color: #cc00cc;
        }

        /* Pong game styles within modal */
        #pongCanvas {
            border: 2px solid #00ffff;
            background-color: #222;
            box-shadow: 0 0 10px #00ffff;
            width: 100%;
            max-width: 800px;
            height: auto;
            aspect-ratio: 2 / 1;
        }

        #difficulty {
            margin-bottom: 10px;
        }

        #difficulty select {
            font-size: 0.8em;
            padding: 5px;
            background-color: #222;
            color: #00ff00;
            border: 2px solid #00ffff;
            box-shadow: 0 0 5px #00ffff;
        }

        #startBtn {
            font-size: 0.8em;
            padding: 10px 20px;
            margin-bottom: 15px;
            cursor: pointer;
            background-color: #00ffff;
            color: #000;
            border: none;
            border-radius: 5px;
            box-shadow: 0 4px #00cccc;
            transition: all 0.1s;
            width: 120px;
            text-shadow: none;
        }

        #startBtn:active {
            box-shadow: 0 2px #00cccc;
            transform: translateY(2px);
        }

        #startBtn:hover {
            background-color: #00cccc;
        }

        #pongControls button {
            font-size: 1em;
            padding: 15px;
            cursor: pointer;
            background-color: #00ff00;
            color: #000;
            border: none;
            border-radius: 5px;
            width: 60px;
            height: 60px;
            line-height: 1;
            box-shadow: 0 4px #00cc00;
            transition: all 0.1s;
            text-shadow: none;
        }

        #pongControls button:active {
            background-color: #00cc00;
            box-shadow: 0 2px #00cc00;
            transform: translateY(2px);
        }

        #pongControls button:hover {
            background-color: #00cc00;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-size: 1.2em;
            text-align: center;
            text-shadow: 0 0 5px #ffff00;
            display: none;
        }

        #winnerText {
            margin-bottom: 10px;
        }

        /* Arcade background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 255, 0.1) 0%, rgba(0, 0, 0, 0.8) 100%);
            z-index: -1;
        }

        /* Media queries for mobile view */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.4em;
            }

            main {
                padding: 20px;
            }

            h2 {
                font-size: 1em;
            }

            p {
                font-size: 0.8em;
            }

            .game-card {
                width: 150px;
                padding: 10px;
                margin: 8px;
            }

            .game-image {
                height: 120px;
                font-size: 0.6em;
            }

            .game-card span {
                font-size: 0.7em;
            }

            .modal-content {
                width: 95%;
            }

            #gameCanvas, #pongCanvas {
                width: 300px;
                height: 300px;
            }

            .control-btn, #pongControls button {
                width: 40px;
                height: 40px;
                font-size: 0.7em;
            }

            #pause-play-btn, #restart-btn, #startBtn {
                font-size: 0.7em;
                padding: 8px 16px;
            }
        }

                

        @media (max-width: 480px) {
            h1 {
                font-size: 1.2em;
            }

            main {
                padding: 15px;
            }

            h2 {
                font-size: 0.9em;
            }

            p {
                font-size: 0.7em;
            }

            .game-card {
                width: 120px;
                padding: 8px;
                margin: 5px;
            }

            .game-image {
                height: 100px;
                font-size: 0.5em;
            }

            .game-card span {
                font-size: 0.6em;
            }

            #gameCanvas {
                width: 250px;
                height: 250px;
            }

            #pongCanvas {
                width: 90vw;
                height: auto;
            }

            .control-btn, #pongControls button {
                width: 35px;
                height: 35px;
                font-size: 0.6em;
            }

            #pause-play-btn, #restart-btn, #startBtn {
                font-size: 0.6em;
                padding: 6px 12px;
            }

            #gameOver {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Classic Arcade Games Online</h1>
    </header>
    <main>
        <section id="classic-arcade">
            <h2>Classic Arcade-Style Games</h2>
            <p>Relive the golden age of gaming with iconic arcade titles. Fast-paced, pixel-perfect fun awaits!</p>
            <div class="game-card" data-game="pong">
                <div class="game-image">Image Placeholder</div>
                <span>Pong</span>
            </div>
            <div class="game-card" data-game="breakout">
                <div class="game-image">Image Placeholder</div>
                <span>Breakout</span>
            </div>
            <div class="game-card" data-game="snake">
                <div class="game-image">Image Placeholder</div>
                <span>Snake</span>
            </div>
            <div class="game-card" data-game="tetris">
                <div class="game-image">Image Placeholder</div>
                <span>Tetris</span>
            </div>
            <div class="game-card" data-game="flappy-bird">
                <div class="game-image">Image Placeholder</div>
                <span>Flappy Bird</span>
            </div>
            <div class="game-card" data-game="space-invaders">
                <div class="game-image">Image Placeholder</div>
                <span>Space Invaders</span>
            </div>
            <div class="game-card" data-game="frogger">
                <div class="game-image">Image Placeholder</div>
                <span>Frogger</span>
            </div>
            <div class="game-card" data-game="centipede">
                <div class="game-image">Image Placeholder</div>
                <span>Centipede</span>
            </div>
            <div class="game-card" data-game="qix">
                <div class="game-image">Image Placeholder</div>
                <span>Qix</span>
            </div>
        </section>
        <section id="puzzle-logic">
            <h2>Puzzle and Logic Games</h2>
            <p>Challenge your mind with brain-teasing games. Strategize and solve your way to victory.</p>
            <div class="game-card" data-game="2048">
                <div class="game-image">Image Placeholder</div>
                <span>2048</span>
            </div>
            <div class="game-card" data-game="minesweeper">
                <div class="game-image">Image Placeholder</div>
                <span>Minesweeper</span>
            </div>
            <div class="game-card" data-game="sudoku">
                <div class="game-image">Image Placeholder</div>
                <span>Sudoku</span>
            </div>
            <div class="game-card" data-game="simon-says">
                <div class="game-image">Image Placeholder</div>
                <span>Simon Says</span>
            </div>
            <div class="game-card" data-game="lights-out">
                <div class="game-image">Image Placeholder</div>
                <span>Lights Out</span>
            </div>
            <div class="game-card" data-game="15-puzzle">
                <div class="game-image">Image Placeholder</div>
                <span>15-Puzzle</span>
            </div>
            <div class="game-card" data-game="nonogram">
                <div class="game-image">Image Placeholder</div>
                <span>Nonogram</span>
            </div>
            <div class="game-card" data-game="sokoban">
                <div class="game-image">Image Placeholder</div>
                <span>Sokoban</span>
            </div>
            <div class="game-card" data-game="mastermind">
                <div class="game-image">Image Placeholder</div>
                <span>Mastermind</span>
            </div>
            <div class="game-card" data-game="wotski">
                <div class="game-image">Image Placeholder</div>
                <span>Wotski</span>
            </div>
        </section>
        <section id="card-board">
            <h2>Card and Board Games</h2>
            <p>Enjoy timeless classics. Perfect for quick sessions or relaxing gameplay.</p>
            <div class="game-card" data-game="tic-tac-toe">
                <div class="game-image">Image Placeholder</div>
                <span>Tic-Tac-Toe</span>
            </div>
            <div class="game-card" data-game="connect-four">
                <div class="game-image">Image Placeholder</div>
                <span>Connect Four</span>
            </div>
            <div class="game-card" data-game="solitaire">
                <div class="game-image">Image Placeholder</div>
                <span>Solitaire</span>
            </div>
            <div class="game-card" data-game="blackjack">
                <div class="game-image">Image Placeholder</div>
                <span>Blackjack</span>
            </div>
            <div class="game-card" data-game="memory-match">
                <div class="game-image">Image Placeholder</div>
                <span>Memory Match</span>
            </div>
            <div class="game-card" data-game="war">
                <div class="game-image">Image Placeholder</div>
                <span>War</span>
            </div>
            <div class="game-card" data-game="go-fish">
                <div class="game-image">Image Placeholder</div>
                <span>Go Fish</span>
            </div>
            <div class="game-card" data-game="mahjong-solitaire">
                <div class="game-image">Image Placeholder</div>
                <span>Mahjong Solitaire</span>
            </div>
            <div class="game-card" data-game="battleship">
                <div class="game-image">Image Placeholder</div>
                <span>Battleship</span>
            </div>
            <div class="game-card" data-game="checkers">
                <div class="game-image">Image Placeholder</div>
                <span>Checkers</span>
            </div>
        </section>
        <section id="word-trivia">
            <h2>Word and Trivia Games</h2>
            <p>Test your knowledge and vocabulary. Fun for word enthusiasts of all ages.</p>
            <div class="game-card" data-game="hangman">
                <div class="game-image">Image Placeholder</div>
                <span>Hangman</span>
            </div>
            <div class="game-card" data-game="wordle">
                <div class="game-image">Image Placeholder</div>
                <span>Wordle</span>
            </div>
            <div class="game-card" data-game="boggle">
                <div class="game-image">Image Placeholder</div>
                <span>Boggle</span>
            </div>
            <div class="game-card" data-game="word-search">
                <div class="game-image">Image Placeholder</div>
                <span>Word Search</span>
            </div>
            <div class="game-card" data-game="trivia-quiz">
                <div class="game-image">Image Placeholder</div>
                <span>Trivia Quiz</span>
            </div>
            <div class="game-card" data-game="anagram-solver">
                <div class="game-image">Image Placeholder</div>
                <span>Anagram Solver</span>
            </div>
            <div class="game-card" data-game="crossword">
                <div class="game-image">Image Placeholder</div>
                <span>Crossword</span>
            </div>
        </section>
        <section id="action-platform">
            <h2>Action and Platform Games</h2>
            <p>Jump, run, and dodge obstacles in action-packed adventures.</p>
            <div class="game-card" data-game="endless-runner">
                <div class="game-image">Image Placeholder</div>
                <span>Endless Runner</span>
            </div>
            <div class="game-card" data-game="doodle-jump">
                <div class="game-image">Image Placeholder</div>
                <span>Doodle Jump</span>
            </div>
            <div class="game-card" data-game="simple-platformer">
                <div class="game-image">Image Placeholder</div>
                <span>Simple Platformer</span>
            </div>
        </section>
        <section id="utility-mini">
            <h2>Utility and Mini Games</h2>
            <p>Play quick, addictive mini-games. Simple yet endlessly entertaining.</p>
            <div class="game-card" data-game="whack-a-mole">
                <div class="game-image">Image Placeholder</div>
                <span>Whack-a-Mole</span>
            </div>
            <div class="game-card" data-game="typing-speed-test">
                <div class="game-image">Image Placeholder</div>
                <span>Typing Speed Test</span>
            </div>
            <div class="game-card" data-game="rock-paper-scissors">
                <div class="game-image">Image Placeholder</div>
                <span>Rock Paper Scissors</span>
            </div>
            <div class="game-card" data-game="number-guessing">
                <div class="game-image">Image Placeholder</div>
                <span>Number Guessing</span>
            </div>
            
            <div class="game-card" data-game="color-flood">
                <div class="game-image">Image Placeholder</div>
                <span>Color Flood</span>
            </div>
            <div class="game-card" data-game="morse-code-trainer">
                <div class="game-image">Image Placeholder</div>
                <span>Morse Code Trainer</span>
            </div>
        </section>
        <section id="simulation-idle">
            <h2>Simulation and Idle Games</h2>
            <p>Immerse yourself in engaging simulations or relax with idle games that progress with minimal input.</p>
            <div class="game-card" data-game="cookie-clicker">
                <div class="game-image">Image Placeholder</div>
                <span>Cookie Clicker</span>
            </div>
            <div class="game-card" data-game="idle-miner">
                <div class="game-image">Image Placeholder</div>
                <span>Idle Miner</span>
            </div>
            <div class="game-card" data-game="virtual-pet">
                <div class="game-image">Image Placeholder</div>
                <span>Virtual Pet</span>
            </div>
        </section>
    </main>
    <!-- Modal for game content -->
    <div id="gameModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="modal-body"></div>
        </div>
    </div>
    <script>
        // Random header color flicker
        function getRandomColor() {
            return ['#ffff00', '#ff00ff', '#00ffff', '#00ff00'][Math.floor(Math.random() * 4)];
        }

        setInterval(() => {
            const h1 = document.querySelector('h1');
            const color = getRandomColor();
            h1.style.color = color;
            h1.style.textShadow = `0 0 10px ${color}`;
        }, 2000);

        // Modal functionality
        const modal = document.getElementById('gameModal');
        const closeBtn = document.querySelector('.close');
        const modalBody = document.getElementById('modal-body');
        const gameCards = document.querySelectorAll('.game-card');
    let snakeGameLoop = null;
    let pongGameLoop = null;
    let minesweeperInterval = null;
    let activeGameCleanup = null;

        function loadSnakeGame() {
            modalBody.innerHTML = `
                <h3 id="gameTitle">Snake</h3>
                <div id="game-container">
                    <div id="score">Score: 0 | High Score: 0</div>
                    <canvas id="gameCanvas" width="400" height="400"></canvas>
                    <div id="instructions">Use buttons to move the snake. Eat the red food to grow!</div>
                    <div id="controls">
                        <div class="d-pad">
                            <button id="up-btn" class="control-btn">Up</button>
                        </div>
                        <div class="d-pad">
                            <button id="left-btn" class="control-btn">Left</button>
                            <button id="down-btn" class="control-btn">Down</button>
                            <button id="right-btn" class="control-btn">Right</button>
                        </div>
                    </div>
                    <button id="pause-play-btn">Pause</button>
                    <button id="restart-btn" style="display: none;">Restart Game</button>
                </div>
            `;

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const restartBtn = document.getElementById('restart-btn');
            const instructions = document.getElementById('instructions');
            const pausePlayBtn = document.getElementById('pause-play-btn');

            const gridSize = 20;
            const gridWidth = canvas.width / gridSize;
            const gridHeight = canvas.height / gridSize;

            let snake = [{ x: 10, y: 10 }];
            let food = { x: Math.floor(Math.random() * gridWidth), y: Math.floor(Math.random() * gridHeight) };
            let bonusFood = null;
            let direction = { x: 0, y: 0 };
            let score = 0;
            let highScore = localStorage.getItem('snakeHighScore') ? parseInt(localStorage.getItem('snakeHighScore')) : 0;
            let gameOver = false;
            let isPaused = false;
            let normalFoodEaten = 0;

            scoreElement.textContent = `Score: ${score} | High Score: ${highScore}`;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ff00';
                snake.forEach(segment => {
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                });
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
                if (bonusFood) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(bonusFood.x * gridSize, bonusFood.y * gridSize, gridSize - 2, gridSize - 2);
                }

                // Whack-a-Mole loader moved to top-level (was accidentally inserted inside Snake.draw)
            }

            function update() {
                if (gameOver || isPaused) return;

                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

                if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
                    gameOver = true;
                    endGame();
                    return;
                }

                for (let i = 1; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        gameOver = true;
                        endGame();
                        return;
                    }
                }

                snake.unshift(head);

                if (head.x === food.x && head.y === food.y) {
                    score += 1;
                    normalFoodEaten += 1;
                    if (normalFoodEaten % 7 === 0) {
                        spawnBonusFood();
                    }
                    food = { x: Math.floor(Math.random() * gridWidth), y: Math.floor(Math.random() * gridHeight) };
                } else if (bonusFood && head.x === bonusFood.x && head.y === bonusFood.y) {
                    score += 5;
                    bonusFood = null;
                } else {
                    snake.pop();
                }

                updateScoreDisplay();
            }

            function spawnBonusFood() {
                let x = Math.floor(Math.random() * gridWidth);
                let y = Math.floor(Math.random() * gridHeight);
                while ((x === food.x && y === food.y) || snake.some(segment => segment.x === x && segment.y === y)) {
                    x = Math.floor(Math.random() * gridWidth);
                    y = Math.floor(Math.random() * gridHeight);
                }
                bonusFood = { x, y };
            }

            function updateScoreDisplay() {
                scoreElement.textContent = `Score: ${score} | High Score: ${highScore}`;
            }

            function moveUp() {
                if (direction.y !== 1 && !gameOver && !isPaused) direction = { x: 0, y: -1 };
            }

            function moveDown() {
                if (direction.y !== -1 && !gameOver && !isPaused) direction = { x: 0, y: 1 };
            }

            function moveLeft() {
                if (direction.x !== 1 && !gameOver && !isPaused) direction = { x: -1, y: 0 };
            }

            function moveRight() {
                if (direction.x !== -1 && !gameOver && !isPaused) direction = { x: 1, y: 0 };
            }

            function endGame() {
                instructions.textContent = 'Game Over! Press Restart to play again.';
                restartBtn.style.display = 'block';
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('snakeHighScore', highScore);
                }
            }

            function restartGame() {
                snake = [{ x: 10, y: 10 }];
                direction = { x: 0, y: 0 };
                score = 0;
                normalFoodEaten = 0;
                bonusFood = null;
                gameOver = false;
                food = { x: Math.floor(Math.random() * gridWidth), y: Math.floor(Math.random() * gridHeight) };
                updateScoreDisplay();
                instructions.textContent = 'Use buttons to move the snake. Eat the red food to grow!';
                restartBtn.style.display = 'none';
                isPaused = false;
                pausePlayBtn.textContent = 'Pause';
                gameLoop();
            }

            function gameLoop() {
                update();
                draw();
                if (!gameOver && !isPaused) {
                    snakeGameLoop = setTimeout(gameLoop, 200);
                }
            }

            document.getElementById('up-btn').addEventListener('click', moveUp);
            document.getElementById('down-btn').addEventListener('click', moveDown);
            document.getElementById('left-btn').addEventListener('click', moveLeft);
            document.getElementById('right-btn').addEventListener('click', moveRight);
            document.getElementById('pause-play-btn').addEventListener('click', togglePause);
            document.getElementById('restart-btn').addEventListener('click', restartGame);

            function togglePause() {
                if (gameOver) return;
                isPaused = !isPaused;
                pausePlayBtn.textContent = isPaused ? 'Play' : 'Pause';
                if (!isPaused) gameLoop();
            }

            gameLoop();
        }

        function loadPongGame() {
            modalBody.innerHTML = `
                <h3 id="gameTitle">Pong</h3>
                <div id="gameContainer">
                    <div id="instructions">Use ‚Üë/‚Üì buttons to control the left paddle (Player)</div>
                    <div id="score">Player: 0 | Computer: 0</div>
                    <div id="difficulty">
                        <label for="diffSelect" style="color: #00ff00; text-shadow: 0 0 5px #00ff00;">Difficulty: </label>
                        <select id="diffSelect">
                            <option value="easy">Easy</option>
                            <option value="medium" selected>Medium</option>
                            <option value="hard">Hard</option>
                        </select>
                    </div>
                    <button id="startBtn">Start</button>
                    <canvas id="pongCanvas" width="800" height="400"></canvas>
                    <div id="pongControls">
                        <button id="upBtn">‚Üë</button>
                        <button id="downBtn">‚Üì</button>
                    </div>
                    <div id="gameOver">
                        <div id="winnerText"></div>
                        <button id="restartBtn">Restart Game</button>
                    </div>
                </div>
            `;

            const canvas = document.getElementById('pongCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const diffSelect = document.getElementById('diffSelect');
            const gameOver = document.getElementById('gameOver');
            const winnerText = document.getElementById('winnerText');
            const restartBtn = document.getElementById('restartBtn');
            const upBtn = document.getElementById('upBtn');
            const downBtn = document.getElementById('downBtn');
            const startBtn = document.getElementById('startBtn');

            const paddleHeight = 100;
            const paddleWidth = 10;
            const ballSize = 10;
            const paddleSpeed = 8;
            let baseBallSpeed = 6;
            let ballSpeed = baseBallSpeed;
            const winningScore = 5;

            let paddle1Y = (canvas.height - paddleHeight) / 2;
            let paddle2Y = (canvas.height - paddleHeight) / 2;
            let ballX = canvas.width / 2;
            let ballY = canvas.height / 2;
            let ballDX = ballSpeed;
            let ballDY = ballSpeed;
            let playerScore = 0;
            let computerScore = 0;
            let gamePaused = true;
            let gameStarted = false;

            let aiSpeed = 3;
            let aiReactionTime = 20;
            let aiErrorRate = 0.4;
            let speedIncrease = 0;
            function setDifficulty(level) {
                if (level === 'easy') {
                    aiSpeed = 2;
                    aiReactionTime = 25;
                    aiErrorRate = 0.5;
                    baseBallSpeed = 5;
                    speedIncrease = 0;
                } else if (level === 'medium') {
                    aiSpeed = 5;
                    aiReactionTime = 12;
                    aiErrorRate = 0.2;
                    baseBallSpeed = 7;
                    speedIncrease = 0.1;
                } else if (level === 'hard') {
                    aiSpeed = 12;
                    aiReactionTime = 1;
                    aiErrorRate = 0;
                    baseBallSpeed = 10;
                    speedIncrease = 0.5;
                }
                ballSpeed = baseBallSpeed;
                resetBall();
            }
            setDifficulty(diffSelect.value);
            diffSelect.addEventListener('change', (e) => {
                setDifficulty(e.target.value);
                if (!gameStarted) resetBall();
            });

            let movingUp = false;
            let movingDown = false;
            upBtn.addEventListener('mousedown', () => movingUp = true);
            downBtn.addEventListener('mousedown', () => movingDown = true);
            upBtn.addEventListener('mouseup', () => movingUp = false);
            downBtn.addEventListener('mouseup', () => movingDown = false);
            upBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movingUp = true; });
            downBtn.addEventListener('touchend', () => movingUp = false);
            downBtn.addEventListener('touchstart', (e) => { e.preventDefault(); movingDown = true; });
            downBtn.addEventListener('touchend', () => movingDown = false);

            startBtn.addEventListener('click', () => {
                if (!gameStarted) {
                    gamePaused = false;
                    gameStarted = true;
                    startBtn.style.display = 'none';
                    gameLoop();
                }
            });

            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            function playSound(frequency, duration) {
                const oscillator = audioCtx.createOscillator();
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                oscillator.connect(audioCtx.destination);
                oscillator.start();
                setTimeout(() => oscillator.stop(), duration);
            }

            function movePlayer() {
                if (movingUp && paddle1Y > 0) paddle1Y -= paddleSpeed;
                if (movingDown && paddle1Y < canvas.height - paddleHeight) paddle1Y += paddleSpeed;
            }

            let aiFrameCounter = 0;
            function moveAI() {
                aiFrameCounter++;
                if (aiFrameCounter % aiReactionTime !== 0) return;

                let targetY = ballY - paddleHeight / 2;
                if (diffSelect.value === 'hard' && ballDX > 0) {
                    const timeToReach = (canvas.width - paddleWidth - ballX) / ballDX;
                    targetY = ballY + ballDY * timeToReach - paddleHeight / 2;
                    targetY = Math.max(0, Math.min(canvas.height - paddleHeight, targetY));
                }

                const error = (Math.random() < aiErrorRate) ? (Math.random() - 0.5) * 100 : 0;
                const adjustedTarget = targetY + error;

                if (paddle2Y + paddleHeight / 2 < adjustedTarget) {
                    paddle2Y += aiSpeed;
                } else if (paddle2Y + paddleHeight / 2 > adjustedTarget) {
                    paddle2Y -= aiSpeed;
                }

                paddle2Y = Math.max(0, Math.min(canvas.height - paddleHeight, paddle2Y));
            }

            function moveBall() {
                ballX += ballDX;
                ballY += ballDY;

                if (ballY + ballSize > canvas.height || ballY < 0) {
                    ballDY = -ballDY;
                    playSound(440, 50);
                }

                if (ballX < paddleWidth && ballY > paddle1Y && ballY < paddle1Y + paddleHeight) {
                    const hitPos = (ballY - (paddle1Y + paddleHeight / 2)) / (paddleHeight / 2);
                    ballDX = ballSpeed * Math.cos(hitPos * Math.PI / 4);
                    ballDY = ballSpeed * Math.sin(hitPos * Math.PI / 4);
                    ballSpeed += speedIncrease;
                    playSound(523, 50);
                } else if (ballX > canvas.width - paddleWidth - ballSize && ballY > paddle2Y && ballY < paddle2Y + paddleHeight) {
                    const hitPos = (ballY - (paddle2Y + paddleHeight / 2)) / (paddleHeight / 2);
                    ballDX = -ballSpeed * Math.cos(hitPos * Math.PI / 4);
                    ballDY = ballSpeed * Math.sin(hitPos * Math.PI / 4);
                    ballSpeed += speedIncrease;
                    playSound(523, 50);
                }

                if (ballX < 0) {
                    computerScore++;
                    playSound(220, 200);
                    resetBall();
                    checkGameOver();
                } else if (ballX > canvas.width) {
                    playerScore++;
                    playSound(659, 200);
                    resetBall();
                    checkGameOver();
                }
            }

            function resetBall() {
                ballX = canvas.width / 2;
                ballY = canvas.height / 2;
                ballSpeed = baseBallSpeed;
                const angle = (Math.random() - 0.5) * Math.PI / 2;
                ballDX = ballSpeed * (ballDX > 0 ? 1 : -1) * Math.cos(angle);
                ballDY = ballSpeed * Math.sin(angle);
            }

            function checkGameOver() {
                if (playerScore >= winningScore || computerScore >= winningScore) {
                    gamePaused = true;
                    gameStarted = false;
                    winnerText.textContent = playerScore >= winningScore ? 'You Win!' : 'Computer Wins!';
                    gameOver.style.display = 'block';
                    startBtn.style.display = 'block';
                    startBtn.textContent = 'Play Again';
                }
            }

            restartBtn.addEventListener('click', () => {
                playerScore = 0;
                computerScore = 0;
                gamePaused = true;
                gameStarted = false;
                gameOver.style.display = 'none';
                startBtn.style.display = 'block';
                startBtn.textContent = 'Start';
                scoreElement.textContent = `Player: ${playerScore} | Computer: ${computerScore}`;
                resetBall();
                setDifficulty(diffSelect.value);
            });

            function draw() {
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#00ffff';
                ctx.fillRect(0, paddle1Y, paddleWidth, paddleHeight);
                ctx.fillRect(canvas.width - paddleWidth, paddle2Y, paddleWidth, paddleHeight);

                ctx.beginPath();
                ctx.arc(ballX, ballY, ballSize / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#ffff00';
                ctx.fill();
                ctx.closePath();

                ctx.setLineDash([5, 15]);
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, canvas.height);
                ctx.strokeStyle = '#00ff00';
                ctx.stroke();
                ctx.setLineDash([]);

                scoreElement.textContent = `Player: ${playerScore} | Computer: ${computerScore}`;
            }

            function gameLoop() {
                if (!gamePaused) {
                    movePlayer();
                    moveAI();
                    moveBall();
                }
                draw();
                if (gameStarted) {
                    pongGameLoop = requestAnimationFrame(gameLoop);
                }
            }

            draw();
        }

        function loadMinesweeperGame() {
            modalBody.innerHTML = `
                <style>
                  #ms-controls { margin-bottom: 10px; }
                  #ms-board { display: grid; gap: 2px; margin: 20px auto; width: fit-content; }
                  .ms-cell { width: 30px; height: 30px; background: #ccc; border: 1px solid #999; font-size: 18px; font-weight: bold; text-align: center; line-height: 30px; cursor: pointer; user-select: none; }
                  .ms-revealed { background: #eee; cursor: default; }
                  .ms-mine { background: red; color: white; }
                  .ms-flagged { background: #ffc; color: #333; }
                </style>
                <h3 id="gameTitle">Minesweeper</h3>
                <div id="ms-controls">
                  <label for="ms-difficulty">Difficulty:</label>
                  <select id="ms-difficulty">
                    <option value="easy">Easy (8√ó8)</option>
                    <option value="medium">Medium (10√ó10)</option>
                    <option value="hard">Hard (12√ó12)</option>
                  </select>
                  <button id="ms-start">Start Game</button>
                </div>
                <div id="ms-timer">‚è±Ô∏è Time: 0s</div>
                <div id="ms-score">‚≠ê Score: 0</div>
                <div id="ms-board"></div>
                <div id="ms-status"></div>
            `;

            const boardEl = document.getElementById('ms-board');
            const statusEl = document.getElementById('ms-status');
            const timerEl = document.getElementById('ms-timer');
            const scoreEl = document.getElementById('ms-score');
            const difficultyEl = document.getElementById('ms-difficulty');
            const startBtn = document.getElementById('ms-start');

            let size = 8;
            let mineCount = 10;
            let cells = [];
            let gameOver = false;
            let timer = 0;

            function initGame() {
                clearInterval(minesweeperInterval);
                timer = 0;
                timerEl.textContent = '‚è±Ô∏è Time: 0s';
                scoreEl.textContent = '‚≠ê Score: 0';
                statusEl.textContent = '';
                gameOver = false;

                const level = difficultyEl.value;
                if (level === 'easy') { size = 8; mineCount = 10; }
                if (level === 'medium') { size = 10; mineCount = 15; }
                if (level === 'hard') { size = 12; mineCount = 25; }

                boardEl.innerHTML = '';
                boardEl.style.gridTemplateColumns = `repeat(${size}, 30px)`;
                boardEl.style.gridTemplateRows = `repeat(${size}, 30px)`;
                cells = [];

                for (let i = 0; i < size * size; i++) {
                    const cellEl = document.createElement('div');
                    cellEl.classList.add('ms-cell');
                    cellEl.dataset.index = i;
                    // named handlers so we can remove them in cleanup
                    const onClick = () => revealCell(i);
                    const onContext = (e) => { e.preventDefault(); toggleFlag(i); };
                    cellEl.addEventListener('click', onClick);
                    cellEl.addEventListener('contextmenu', onContext);
                    boardEl.appendChild(cellEl);
                    // store handlers so cleanup can remove them
                    cells.push({ element: cellEl, mine: false, revealed: false, flagged: false, adjacent: 0, handlers: { onClick, onContext } });
                }

                let minesPlaced = 0;
                while (minesPlaced < mineCount) {
                    const i = Math.floor(Math.random() * cells.length);
                    if (!cells[i].mine) { cells[i].mine = true; minesPlaced++; }
                }

                for (let i = 0; i < cells.length; i++) {
                    const neighbors = getNeighbors(i);
                    cells[i].adjacent = neighbors.filter(n => cells[n].mine).length;
                }

                minesweeperInterval = setInterval(() => { timer++; timerEl.textContent = `‚è±Ô∏è Time: ${timer}s`; }, 1000);
            }

            function getNeighbors(index) {
                const neighbors = [];
                const row = Math.floor(index / size);
                const col = index % size;
                for (let r = -1; r <= 1; r++) {
                    for (let c = -1; c <= 1; c++) {
                        if (r === 0 && c === 0) continue;
                        const nr = row + r;
                        const nc = col + c;
                        if (nr >= 0 && nr < size && nc >= 0 && nc < size) neighbors.push(nr * size + nc);
                    }
                }
                return neighbors;
            }

            function revealCell(index) {
                const cell = cells[index];
                if (cell.revealed || cell.flagged || gameOver) return;
                cell.revealed = true;
                cell.element.classList.add('ms-revealed');
                if (cell.mine) {
                    cell.element.classList.add('ms-mine');
                    cell.element.textContent = 'üí£';
                    statusEl.textContent = 'üí• Game Over!';
                    gameOver = true;
                    clearInterval(minesweeperInterval);
                    revealAllMines();
                    return;
                }
                if (cell.adjacent > 0) {
                    cell.element.textContent = cell.adjacent;
                } else {
                    getNeighbors(index).forEach(revealCell);
                }
                checkWin();
            }

            function toggleFlag(index) {
                const cell = cells[index];
                if (cell.revealed || gameOver) return;
                cell.flagged = !cell.flagged;
                cell.element.classList.toggle('ms-flagged');
                cell.element.textContent = cell.flagged ? 'üö©' : '';
            }

            function revealAllMines() {
                cells.forEach(c => { if (c.mine) { c.element.classList.add('ms-mine'); c.element.textContent = 'üí£'; } });
            }

            function checkWin() {
                const unrevealed = cells.filter(c => !c.revealed);
                const onlyMinesLeft = unrevealed.every(c => c.mine);
                if (onlyMinesLeft && !gameOver) {
                    statusEl.textContent = 'üéâ You Win!';
                    gameOver = true;
                    clearInterval(minesweeperInterval);
                    const score = Math.max(1000 - timer * 5, 0);
                    scoreEl.textContent = `‚≠ê Score: ${score}`;
                }
            }

            startBtn.addEventListener('click', initGame);
            // start immediately
            initGame();

            // cleanup for minesweeper: remove per-cell listeners and stop timer
            activeGameCleanup = function(){
                try{
                    // remove cell listeners
                    cells.forEach(c => {
                        if(c && c.element && c.handlers){
                            c.element.removeEventListener('click', c.handlers.onClick);
                            c.element.removeEventListener('contextmenu', c.handlers.onContext);
                        }
                    });
                    // clear interval
                    if(minesweeperInterval){ clearInterval(minesweeperInterval); minesweeperInterval = null; }
                }catch(e){ console.error('minesweeper cleanup', e); }
                activeGameCleanup = null;
            };
        }

                function loadSudokuGame() {
                        modalBody.innerHTML = `
                                <style>
                                    #sudoku-board { display: grid; gap: 2px; margin: 20px auto; width: fit-content; }
                                    #sudoku-board input { text-align: center; font-size: 18px; border: 1px solid #999; background: white; }
                                    #sudoku-board input[readonly] { background: #ddd; font-weight: bold; }
                                    #sudoku-controls { margin-top: 12px; }
                                </style>
                                <h3 id="gameTitle">Sudoku</h3>
                                <div id="sudoku-level-select">
                                    <label for="sudoku-level">Choose Level:</label>
                                    <select id="sudoku-level">
                                        <option value="easy">Easy (4√ó4)</option>
                                        <option value="medium">Medium (6√ó6)</option>
                                        <option value="hard">Hard (9√ó9)</option>
                                    </select>
                                </div>
                                <div id="sudoku-board"></div>
                                <div id="sudoku-controls">
                                    <button id="sudoku-check">Check</button>
                                    <button id="sudoku-reset">Reset</button>
                                </div>
                                <div id="sudoku-message"></div>
                        `;

                        const boardEl = document.getElementById('sudoku-board');
                        const messageEl = document.getElementById('sudoku-message');
                        const levelEl = document.getElementById('sudoku-level');
                        const checkBtn = document.getElementById('sudoku-check');
                        const resetBtn = document.getElementById('sudoku-reset');

                        const puzzles = {
                            easy: [
                                [0,2,3,0, 3,0,0,1, 0,0,1,4, 1,0,2,0],
                                [1,0,0,4, 0,0,3,0, 0,2,0,0, 4,0,0,1]
                            ],
                            medium: [
                                [0,0,3,0,0,6, 0,5,0,0,3,0, 6,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
                                [1,0,0,0,0,0, 0,2,0,0,0,0, 0,0,3,0,0,0, 0,0,0,4,0,0, 0,0,0,0,5,0, 0,0,0,0,0,6]
                            ],
                            hard: [
                                [5,3,0,0,7,0,0,0,0, 6,0,0,1,9,5,0,0,0, 0,9,8,0,0,0,0,6,0, 8,0,0,0,6,0,0,0,3, 4,0,0,8,0,3,0,0,1, 7,0,0,0,2,0,0,0,6, 0,6,0,0,0,0,2,8,0, 0,0,0,4,1,9,0,0,5, 0,0,0,0,8,0,0,7,9],
                                [0,0,0,2,6,0,7,0,1, 6,8,0,0,7,0,0,9,0, 1,9,0,0,0,4,5,0,0, 8,2,0,1,0,0,0,4,0, 0,0,4,6,0,2,9,0,0, 0,5,0,0,0,3,0,2,8, 0,0,9,3,0,0,0,7,4, 0,4,0,0,5,0,0,3,6, 7,0,3,0,1,8,0,0,0]
                            ]
                        };

                        function loadPuzzle() {
                            const level = levelEl.value;
                            const size = level === 'easy' ? 4 : level === 'medium' ? 6 : 9;
                            const raw = puzzles[level][Math.floor(Math.random() * puzzles[level].length)];
                            boardEl.innerHTML = '';
                            boardEl.style.gridTemplateColumns = `repeat(${size}, 40px)`;
                            boardEl.style.gridTemplateRows = `repeat(${size}, 40px)`;
                            for (let i = 0; i < size * size; i++) {
                                const input = document.createElement('input');
                                input.type = 'text';
                                input.maxLength = 1;
                                input.style.width = '38px';
                                input.style.height = '38px';
                                const val = raw[i] || 0;
                                if (val !== 0) { input.value = val; input.readOnly = true; }
                                input.addEventListener('input', () => {
                                    const max = size;
                                    if (!new RegExp(`^[1-${max}]$`).test(input.value)) input.value = '';
                                });
                                boardEl.appendChild(input);
                            }
                            messageEl.textContent = '';
                        }

                        function getGridValues(size) {
                            const values = [];
                            for (let i = 0; i < size * size; i++) {
                                const val = boardEl.children[i].value;
                                values.push(val ? parseInt(val) : 0);
                            }
                            const grid = [];
                            for (let i = 0; i < size; i++) grid.push(values.slice(i * size, i * size + size));
                            return grid;
                        }

                        function validateSudoku(grid, size, level) {
                            for (let i = 0; i < size; i++) {
                                const row = new Set();
                                const col = new Set();
                                for (let j = 0; j < size; j++) {
                                    const r = grid[i][j];
                                    const c = grid[j][i];
                                    if (r === 0 || row.has(r)) return false;
                                    if (c === 0 || col.has(c)) return false;
                                    row.add(r); col.add(c);
                                }
                            }
                            const boxSize = level === 'easy' ? 2 : level === 'medium' ? 2 : 3;
                            for (let r = 0; r < size; r += boxSize) {
                                for (let c = 0; c < size; c += boxSize) {
                                    const box = new Set();
                                    for (let i = 0; i < boxSize; i++) {
                                        for (let j = 0; j < boxSize; j++) {
                                            const val = grid[r + i][c + j];
                                            if (val === 0 || box.has(val)) return false;
                                            box.add(val);
                                        }
                                    }
                                }
                            }
                            return true;
                        }

                        checkBtn.addEventListener('click', () => {
                            const level = levelEl.value;
                            const size = level === 'easy' ? 4 : level === 'medium' ? 6 : 9;
                            const grid = getGridValues(size);
                            const valid = validateSudoku(grid, size, level);
                            messageEl.textContent = valid ? '‚úÖ Correct!' : '‚ùå Incorrect or incomplete.';
                            messageEl.style.color = valid ? 'green' : 'red';
                        });

                        resetBtn.addEventListener('click', loadPuzzle);
                        levelEl.addEventListener('change', loadPuzzle);
                        loadPuzzle();
                }

                    function load2048Game() {
                        modalBody.innerHTML = `
                            <style>
                              #g2048-board { width: 400px; height: 400px; margin: 20px auto; display: grid; grid-template-columns: repeat(4, 1fr); grid-gap: 10px; background: #bbada0; padding: 10px; border-radius: 10px; position: relative; }
                              .g2048-tile { width: 90px; height: 90px; background: #cdc1b4; font-size: 32px; font-weight: bold; color: #776e65; display: flex; align-items: center; justify-content: center; border-radius: 5px; transition: transform 0.2s ease; }
                              .g2048-tile.new { animation: pop 0.3s ease; }
                              @keyframes pop { 0% { transform: scale(0.5); } 100% { transform: scale(1); } }
                              #g2048-game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(238, 228, 218, 0.9); padding: 30px; font-size: 36px; color: #776e65; display: none; border-radius: 10px; z-index: 10; }
                              #g2048-restart { margin-top: 20px; padding: 10px 20px; font-size: 18px; background: #8f7a66; color: white; border: none; border-radius: 5px; cursor: pointer; display: none; }
                            </style>
                            <h3 id="gameTitle">2048</h3>
                            <div id="g2048-score">Score: 0</div>
                            <div id="g2048-highscore">High Score: 0</div>
                            <div id="g2048-board"></div>
                            <div id="g2048-game-over">Game Over!</div>
                            <button id="g2048-restart">Restart</button>
                            <audio id="g2048-merge-sound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg"></audio>
                        `;

                        const gBoard = document.getElementById('g2048-board');
                        const gScore = document.getElementById('g2048-score');
                        const gHigh = document.getElementById('g2048-highscore');
                        const gOver = document.getElementById('g2048-game-over');
                        const gRestart = document.getElementById('g2048-restart');
                        const gMerge = document.getElementById('g2048-merge-sound');

                        let tiles = [];
                        let score = 0;
                        let highscore = parseInt(localStorage.getItem('2048-highscore')) || 0;

                        function updateScores() { gScore.textContent = `Score: ${score}`; gHigh.textContent = `High Score: ${highscore}`; }

                        function createBoard() {
                            gBoard.innerHTML = '';
                            tiles = [];
                            score = 0;
                            updateScores();
                            gOver.style.display = 'none';
                            gRestart.style.display = 'none';
                            for (let i = 0; i < 16; i++) {
                                const tile = document.createElement('div');
                                tile.classList.add('g2048-tile');
                                tile.textContent = '';
                                gBoard.appendChild(tile);
                                tiles.push(tile);
                            }
                            addNewTile(); addNewTile();
                        }

                        function addNewTile() {
                            let empty = tiles.filter(t => t.textContent === '');
                            if (empty.length === 0) return;
                            let t = empty[Math.floor(Math.random() * empty.length)];
                            t.textContent = Math.random() < 0.9 ? '2' : '4';
                            t.classList.add('new');
                            updateTileStyle(t);
                        }

                        function updateTileStyle(tile) {
                            const value = parseInt(tile.textContent);
                            tile.style.background = value ? `rgb(${255 - value * 5}, ${255 - value * 5}, 200)` : '#cdc1b4';
                        }

                        function move(direction) {
                            let moved = false;
                            let getIndex = (r,c)=>r*4+c;
                            for (let i=0;i<4;i++){
                                let line=[];
                                for (let j=0;j<4;j++){
                                    let r = direction==='up'||direction==='down'?j:i;
                                    let c = direction==='up'||direction==='down'?i:j;
                                    if (direction==='right'||direction==='down') c = 3-c;
                                    line.push(tiles[getIndex(r,c)].textContent?parseInt(tiles[getIndex(r,c)].textContent):0);
                                }
                                for (let k=0;k<3;k++){ if (line[k]!==0 && line[k]===line[k+1]){ line[k]*=2; score+=line[k]; line[k+1]=0; gMerge.play(); }}
                                let newLine = line.filter(n=>n!==0); while(newLine.length<4) newLine.push(0);
                                for (let j=0;j<4;j++){ let r = direction==='up'||direction==='down'?j:i; let c = direction==='up'||direction==='down'?i:j; if (direction==='right'||direction==='down') c = 3-c; let idx=getIndex(r,c); if (tiles[idx].textContent !== (newLine[j]?newLine[j].toString():'')) moved=true; tiles[idx].textContent = newLine[j]?newLine[j].toString():''; updateTileStyle(tiles[idx]); }
                            }
                            if (moved){ addNewTile(); if (score>highscore){ highscore=score; localStorage.setItem('2048-highscore', highscore);} updateScores(); checkGameOver(); }
                        }

                        function checkGameOver(){ if (tiles.every(t=>t.textContent!=='')){ for(let i=0;i<16;i++){ let val=parseInt(tiles[i].textContent); let neighbors=[i-1,i+1,i-4,i+4]; for(let n of neighbors){ if(n>=0&&n<16&&Math.abs(n%4 - i%4)<=1){ if(parseInt(tiles[n].textContent)===val) return; } } } gOver.style.display='block'; gRestart.style.display='inline-block'; } }

                        // keyboard and touch handlers for this modal game
                        function onKey(e){ if (e.key==='ArrowLeft') move('left'); if (e.key==='ArrowRight') move('right'); if (e.key==='ArrowUp') move('up'); if (e.key==='ArrowDown') move('down'); }
                        let sx, sy;
                        function onTouchStart(e){ sx=e.touches[0].clientX; sy=e.touches[0].clientY; }
                        function onTouchEnd(e){ let dx=e.changedTouches[0].clientX - sx; let dy=e.changedTouches[0].clientY - sy; if (Math.abs(dx)>Math.abs(dy)){ if (dx>30) move('right'); else if (dx<-30) move('left'); } else { if (dy>30) move('down'); else if (dy<-30) move('up'); } }

                        // attach handlers and provide cleanup
                        document.addEventListener('keydown', onKey);
                        gBoard.addEventListener('touchstart', onTouchStart);
                        gBoard.addEventListener('touchend', onTouchEnd);
                        gRestart.addEventListener('click', createBoard);

                        activeGameCleanup = function(){ document.removeEventListener('keydown', onKey); gBoard.removeEventListener('touchstart', onTouchStart); gBoard.removeEventListener('touchend', onTouchEnd); gRestart.removeEventListener('click', createBoard); activeGameCleanup = null; };

                        createBoard();
                    }

                            function loadSpaceInvadersGame() {
                                modalBody.innerHTML = `
                                            <style>
                                                #si-gameContainer { position: relative; }
                                                #si-gameCanvas { background-color: black; border: 1px solid white; display:block; margin: 0 auto; }
                                                #si-score { position: absolute; top: 10px; left: 10px; font-size: 20px; color: white; }
                                                #si-gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; display: none; color: white; }
                                                #si-buttonContainer { margin-top: 12px; display:flex; gap:8px; justify-content:center; }
                                                #si-buttonContainer button { padding: 8px 14px; font-size: 16px; border-radius:6px; border:none; cursor:pointer; }
                                                #si-start { background: green; color: white; }
                                                #si-pause { background: blue; color: white; }
                                                #si-restart { background: red; color: white; display:none; }
                                            </style>
                                            <div id="si-gameContainer">
                                                <canvas id="si-gameCanvas" width="800" height="600"></canvas>
                                                <div id="si-score">Score: 0</div>
                                                <div id="si-gameOver">Game Over! Use Restart Button</div>
                                            </div>
                                            <div id="si-buttonContainer">
                                                <button id="si-start">Start</button>
                                                <button id="si-pause">Pause</button>
                                                <button id="si-restart">Restart</button>
                                            </div>
                                    `;

                                    const canvas = document.getElementById('si-gameCanvas');
                                    const ctx = canvas.getContext('2d');
                                    const scoreElement = document.getElementById('si-score');
                                    const gameOverElement = document.getElementById('si-gameOver');
                                    const startButton = document.getElementById('si-start');
                                    const pauseButton = document.getElementById('si-pause');
                                    const restartButton = document.getElementById('si-restart');

                                    // Game settings (kept similar to your provided code)
                                    const playerWidth = 60; const playerHeight = 40; const playerSpeed = 5;
                                    const bulletWidth = 5; const bulletHeight = 10; const bulletSpeed = 7;
                                    const alienWidth = 40; const alienHeight = 30; const foodWidth = 20; const foodHeight = 20;
                                    const foodSpeed = 2; const colors = ['red','orange','yellow','green','blue'];
                                    const baseFireRate = 300; const powerUpFireRateMin = 50; const powerUpFireRateMax = 150;
                                    const spawnRate = 600; const foodSpawnRate = 10000; const powerUpDuration = 5000; const waveInterval = 15000;
                                    const waveSizeBase = 8;

                                    // State
                                    let playerX = canvas.width/2 - playerWidth/2;
                                    let playerY = canvas.height - playerHeight - 50;
                                    let bullets = [], aliens = [], foods = [];
                                    let score = 0; let gameOver = false; let paused = true; let started = false;
                                    let animationFrame = 0; let isDragging = false; let lastTouchCanvasX = 0; let lastTouchCanvasY = 0;
                                    let nextShotTime = 0; let powerUpEnd = 0; let currentSpawnRate = spawnRate; let lastSpawn = 0; let lastFoodSpawn = 0; let lastWave = 0;

                                    // Keyboard controls
                                    let keys = {};
                                    function onKeyDown(e){ keys[e.key]=true; if (e.key.toLowerCase()==='r' && gameOver) resetGame(); }
                                    function onKeyUp(e){ keys[e.key]=false; }
                                    document.addEventListener('keydown', onKeyDown);
                                    document.addEventListener('keyup', onKeyUp);

                                    // Touch dragging
                                    function onTouchStart(e){ e.preventDefault(); const rect = canvas.getBoundingClientRect(); lastTouchCanvasX = e.touches[0].clientX - rect.left; lastTouchCanvasY = e.touches[0].clientY - rect.top; isDragging = true; }
                                    function onTouchMove(e){ e.preventDefault(); if (!isDragging) return; const rect = canvas.getBoundingClientRect(); const currentX = e.touches[0].clientX - rect.left; const currentY = e.touches[0].clientY - rect.top; const deltaX = currentX - lastTouchCanvasX; const deltaY = currentY - lastTouchCanvasY; playerX += deltaX; playerY += deltaY; playerX = Math.max(0, Math.min(playerX, canvas.width - playerWidth)); playerY = Math.max(0, Math.min(playerY, canvas.height - playerHeight)); lastTouchCanvasX = currentX; lastTouchCanvasY = currentY; }
                                    function onTouchEnd(e){ e.preventDefault(); isDragging = false; }
                                    canvas.addEventListener('touchstart', onTouchStart);
                                    canvas.addEventListener('touchmove', onTouchMove);
                                    canvas.addEventListener('touchend', onTouchEnd);

                                    // Buttons
                                    startButton.addEventListener('click', ()=>{ if(!started){ started=true; paused=false; startButton.style.display='none'; pauseButton.style.display='inline-block'; restartButton.style.display='none'; } });
                                    pauseButton.addEventListener('click', ()=>{ if(started && !gameOver){ paused = !paused; pauseButton.textContent = paused ? 'Resume' : 'Pause'; } });
                                    restartButton.addEventListener('click', ()=>{ if(gameOver) resetGame(); });

                                    function shoot(){ bullets.push({ x: playerX + playerWidth/2 - bulletWidth/2, y: playerY }); }
                                    function spawnAlien(){ const colorIndex = Math.floor(Math.random()*colors.length); const speed = 1 + score/1000; const vx = (Math.random()-0.5)*2; aliens.push({ x: Math.random()*(canvas.width - alienWidth), y: -alienHeight, vx: vx, vy: speed, alive:true, colorIndex }); }
                                    function spawnFood(){ foods.push({ x: Math.random()*(canvas.width - foodWidth), y: -foodHeight }); }
                                    function spawnWave(num){ for(let i=0;i<num;i++) spawnAlien(); }

                                    function update(){ if(!started || paused || gameOver) return; const now = Date.now(); if(keys['ArrowLeft'] && playerX>0) playerX -= playerSpeed; if(keys['ArrowRight'] && playerX + playerWidth < canvas.width) playerX += playerSpeed; if(keys['ArrowUp'] && playerY>0) playerY -= playerSpeed; if(keys['ArrowDown'] && playerY + playerHeight < canvas.height) playerY += playerSpeed; if(now > nextShotTime){ shoot(); if(now < powerUpEnd){ nextShotTime = now + Math.floor(Math.random()*(powerUpFireRateMax-powerUpFireRateMin))+powerUpFireRateMin; } else { nextShotTime = now + baseFireRate; } } if(now - lastSpawn > currentSpawnRate){ spawnAlien(); lastSpawn = now; currentSpawnRate = Math.max(150, currentSpawnRate - 10); } if(now - lastWave > waveInterval){ const waveSize = waveSizeBase + Math.floor(score/500); spawnWave(waveSize); lastWave = now; } if(now - lastFoodSpawn > foodSpawnRate){ spawnFood(); lastFoodSpawn = now; } bullets = bullets.filter(b=>b.y > -bulletHeight); bullets.forEach(b=>{ b.y -= bulletSpeed; }); aliens.forEach(alien=>{ if(alien.alive){ const targetVx = (playerX + playerWidth/2 - (alien.x + alienWidth/2))*0.01; alien.vx += (targetVx - alien.vx)*0.05; alien.x += alien.vx; alien.y += alien.vy; alien.x += Math.sin(animationFrame/10)*0.5; if(alien.x < 0) alien.x = 0; if(alien.x + alienWidth > canvas.width) alien.x = canvas.width - alienWidth; if(alien.y + alienHeight > canvas.height || checkCollision(alien, {x:playerX, y:playerY, width:playerWidth, height:playerHeight})){ gameOver = true; } } }); aliens = aliens.filter(alien => alien.y < canvas.height && alien.alive); foods.forEach(food => { food.y += foodSpeed; }); foods = foods.filter(food => food.y < canvas.height); bullets.forEach((bullet, bIndex)=>{ aliens.forEach((alien,aIndex)=>{ if(alien.alive && checkCollision(bullet, alien)){ alien.alive = false; bullets.splice(bIndex,1); score += 10; scoreElement.textContent = `Score: ${score}`; } }); }); foods.forEach((food,fIndex)=>{ if(checkCollision(food, {x:playerX, y:playerY, width:playerWidth, height:playerHeight})){ powerUpEnd = now + powerUpDuration; nextShotTime = now; foods.splice(fIndex,1); } }); animationFrame++; if(gameOver){ gameOverElement.style.display = 'block'; pauseButton.style.display = 'none'; restartButton.style.display = 'inline-block'; } }

                                    function checkCollision(a,b){ const aWidth = a.width || alienWidth || foodWidth || bulletWidth; const aHeight = a.height || alienHeight || foodHeight || bulletHeight; const bWidth = b.width || alienWidth || foodWidth || bulletWidth; const bHeight = b.height || alienHeight || foodHeight || bulletHeight; return a.x < b.x + bWidth && a.x + aWidth > b.x && a.y < b.y + bHeight && a.y + aHeight > b.y; }

                                    function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); if(!started){ ctx.fillStyle='white'; ctx.font='24px Arial'; ctx.fillText('Press Start to Begin', canvas.width/2 - 120, canvas.height/2); return; } ctx.fillStyle='cyan'; ctx.beginPath(); ctx.moveTo(playerX + playerWidth/2, playerY); ctx.lineTo(playerX, playerY + playerHeight); ctx.lineTo(playerX + playerWidth/4, playerY + playerHeight/2); ctx.lineTo(playerX + playerWidth/2, playerY + playerHeight/1.5); ctx.lineTo(playerX + playerWidth*3/4, playerY + playerHeight/2); ctx.lineTo(playerX + playerWidth, playerY + playerHeight); ctx.closePath(); ctx.fill(); bullets.forEach(b=>{ ctx.fillStyle = `hsl(${Math.random()*360},100%,50%)`; ctx.fillRect(b.x, b.y, bulletWidth, bulletHeight); }); aliens.forEach(alien=>{ if(alien.alive){ ctx.fillStyle = colors[alien.colorIndex]; ctx.fillRect(alien.x, alien.y + 10, alienWidth, alienHeight - 10); ctx.beginPath(); ctx.arc(alien.x + alienWidth/2, alien.y + 10, alienWidth/4, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(alien.x + alienWidth/3, alien.y + 5, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(alien.x + alienWidth*2/3, alien.y + 5, 3, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = colors[alien.colorIndex]; ctx.lineWidth = 2; const legOffset = (animationFrame % 20 < 10) ? 5 : -5; ctx.beginPath(); ctx.moveTo(alien.x + 10, alien.y + alienHeight); ctx.lineTo(alien.x + 10 + legOffset, alien.y + alienHeight + 10); ctx.stroke(); ctx.beginPath(); ctx.moveTo(alien.x + alienWidth - 10, alien.y + alienHeight); ctx.lineTo(alien.x + alienWidth - 10 - legOffset, alien.y + alienHeight + 10); ctx.stroke(); } }); foods.forEach(food=>{ ctx.fillStyle='purple'; ctx.beginPath(); ctx.arc(food.x + foodWidth/2, food.y + foodHeight/2, foodWidth/2, 0, Math.PI*2); ctx.fill(); }); if(paused){ ctx.fillStyle='white'; ctx.font='30px Arial'; ctx.fillText('Paused', canvas.width/2 - 60, canvas.height/2); } }

                                    let rafId = null;
                                    function loop(){ update(); draw(); rafId = requestAnimationFrame(loop); }

                                    function resetGame(){ score = 0; scoreElement.textContent = `Score: ${score}`; playerX = canvas.width/2 - playerWidth/2; playerY = canvas.height - playerHeight - 50; bullets = []; aliens = []; foods = []; gameOver = false; paused = false; started = true; nextShotTime = 0; powerUpEnd = 0; currentSpawnRate = spawnRate; lastSpawn = 0; lastFoodSpawn = 0; lastWave = 0; gameOverElement.style.display = 'none'; startButton.style.display = 'none'; pauseButton.style.display = 'inline-block'; restartButton.style.display = 'none'; pauseButton.textContent = 'Pause'; }

                                    // Cleanup function to remove listeners and stop animation
                                    activeGameCleanup = function(){ try{ document.removeEventListener('keydown', onKeyDown); document.removeEventListener('keyup', onKeyUp); canvas.removeEventListener('touchstart', onTouchStart); canvas.removeEventListener('touchmove', onTouchMove); canvas.removeEventListener('touchend', onTouchEnd); startButton.removeEventListener('click', ()=>{}); pauseButton.removeEventListener('click', ()=>{}); restartButton.removeEventListener('click', ()=>{}); if(rafId) cancelAnimationFrame(rafId); }catch(e){ console.error('si cleanup', e); } activeGameCleanup = null; };

                                    // Start the loop so the modal shows the start screen and updates
                                    loop();
                            }

                                        function loadFlappyBirdGame() {
                                                modalBody.innerHTML = `
                                                                <style>
                                                                    /* Make Flappy responsive inside the modal: constrain to viewport and keep layout stable */
                                                                    #fb-container {
                                                                        width: min(420px, 90vw);
                                                                        height: min(640px, calc(90vh - 120px));
                                                                        max-height: calc(90vh - 120px);
                                                                        background: #71c5cf;
                                                                        position: relative;
                                                                        border: 2px solid #000;
                                                                        touch-action: none;
                                                                        margin: 0 auto;
                                                                        overflow: hidden;
                                                                    }
                                                                    #fb-bird { width: 40px; height: 30px; background: yellow; position: absolute; left: 100px; border-radius: 50%; border: 2px solid #000; }
                                                                    .fb-pipe { width: 60px; background: green; position: absolute; border: 2px solid #000; }
                                                                    #fb-score { position: absolute; top: 12px; left: 12px; font-size: 20px; color: white; text-shadow: 2px 2px 2px #000; z-index: 20 }
                                                                    #fb-game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; color: red; display: none; z-index: 30 }
                                                                    #fb-controls { margin-top: 12px; display:flex; gap:8px; justify-content:center; }
                                                                    #fb-controls button { padding: 8px 14px; font-size: 16px; border-radius:6px; border:none; cursor:pointer; }
                                                                </style>
                                                        <div id="fb-wrapper">
                                                            <div id="fb-container">
                                                                <div id="fb-bird"></div>
                                                                <div id="fb-score">Score: 0</div>
                                                                <div id="fb-game-over">Game Over!</div>
                                                            </div>
                                                            <div id="fb-controls">
                                                                <button id="fb-start">Start</button>
                                                                <button id="fb-pause">Pause</button>
                                                            </div>
                                                        </div>
                                                `;

                                                const bird = document.getElementById('fb-bird');
                                                const gameContainer = document.getElementById('fb-container');
                                                const scoreDisplay = document.getElementById('fb-score');
                                                const gameOverDisplay = document.getElementById('fb-game-over');
                                                const startBtn = document.getElementById('fb-start');
                                                const pauseBtn = document.getElementById('fb-pause');

                                                let birdY = 300; let birdVelocity = 0; const gravity = 0.4; const flap = -6.0; let score = 0; let gameOver = false; let pipes = []; const pipeSpeed = 2; const pipeGap = 150; const pipeWidth = 60; const pipeFrequency = 1500; let gameStarted = false; let gamePaused = false; let isFlapping = false; let pipeInterval = null;

                                                function updateBird() {
                                                        if (gameStarted && !gamePaused && !gameOver) {
                                                                if (isFlapping) birdVelocity = flap; else birdVelocity += gravity;
                                                                birdY += birdVelocity;
                                                                bird.style.top = birdY + 'px';
                                if (birdY > gameContainer.clientHeight - 30 || birdY < 0) endGame();
                            }
                            }
                                                function startFlap(){ if (gameStarted && !gamePaused && !gameOver) isFlapping = true; }
                                                function stopFlap(){ isFlapping = false; }
                                                gameContainer.addEventListener('touchstart', startFlap);
                                                gameContainer.addEventListener('touchend', stopFlap);
                                                gameContainer.addEventListener('mousedown', startFlap);
                                                gameContainer.addEventListener('mouseup', stopFlap);

                                                function createPipe(){ if (gameStarted && !gamePaused && !gameOver) { const pipeHeight = Math.floor(Math.random() * (gameContainer.clientHeight - pipeGap - 100)) + 50; const topPipe = document.createElement('div'); topPipe.classList.add('fb-pipe'); topPipe.style.height = pipeHeight + 'px'; topPipe.style.top = '0'; topPipe.style.right = '0'; const bottomPipe = document.createElement('div'); bottomPipe.classList.add('fb-pipe'); bottomPipe.style.height = (gameContainer.clientHeight - pipeHeight - pipeGap) + 'px'; bottomPipe.style.bottom = '0'; bottomPipe.style.right = '0'; gameContainer.appendChild(topPipe); gameContainer.appendChild(bottomPipe); pipes.push({ top: topPipe, bottom: bottomPipe, x: gameContainer.clientWidth, scored: false }); } }

                                                function updatePipes(){ if (gameStarted && !gamePaused && !gameOver) { pipes.forEach((pipe, index)=>{ pipe.x -= pipeSpeed; pipe.top.style.right = (gameContainer.clientWidth - pipe.x) + 'px'; pipe.bottom.style.right = (gameContainer.clientWidth - pipe.x) + 'px'; const birdRect = bird.getBoundingClientRect(); const topPipeRect = pipe.top.getBoundingClientRect(); const bottomPipeRect = pipe.bottom.getBoundingClientRect(); if ( birdRect.left < topPipeRect.right && birdRect.right > topPipeRect.left && (birdRect.top < topPipeRect.bottom || birdRect.bottom > bottomPipeRect.top) ) { endGame(); } if (pipe.x + pipeWidth < 100 && !pipe.scored) { score++; scoreDisplay.textContent = `Score: ${score}`; pipe.scored = true; } if (pipe.x + pipeWidth < 0) { pipe.top.remove(); pipe.bottom.remove(); pipes.splice(index,1); } }); } }

                                                function endGame(){ gameOver = true; gameStarted = false; gameOverDisplay.style.display = 'block'; clearInterval(pipeInterval); startBtn.textContent = 'Restart'; }

                                                function startGame(){ if (!gameStarted) { gameStarted = true; gameOver = false; gamePaused = false; score = 0; birdY = 300; birdVelocity = 0; bird.style.top = birdY + 'px'; scoreDisplay.textContent = `Score: ${score}`; gameOverDisplay.style.display = 'none'; pipes.forEach(p=>{ p.top.remove(); p.bottom.remove(); }); pipes = []; pipeInterval = setInterval(createPipe, pipeFrequency); startBtn.textContent = 'Start'; pauseBtn.textContent = 'Pause'; } }

                                                function togglePause(){ if (gameStarted && !gameOver) { gamePaused = !gamePaused; pauseBtn.textContent = gamePaused ? 'Resume' : 'Pause'; } }

                                                startBtn.addEventListener('click', startGame); pauseBtn.addEventListener('click', togglePause);

                                                function gameLoop(){ updateBird(); updatePipes(); requestAnimationFrame(gameLoop); }

                                                gameLoop();

                                                // Cleanup when modal closes
                                                activeGameCleanup = function(){ try{ clearInterval(pipeInterval); gameContainer.removeEventListener('touchstart', startFlap); gameContainer.removeEventListener('touchend', stopFlap); gameContainer.removeEventListener('mousedown', startFlap); gameContainer.removeEventListener('mouseup', stopFlap); startBtn.removeEventListener('click', startGame); pauseBtn.removeEventListener('click', togglePause); } catch(e){ console.error('flappy cleanup', e); } activeGameCleanup = null; };
                                        }

                                                    function loadTetrisGame() {
                                                            modalBody.innerHTML = `
                                                                    <style>
                                                                        #tetris-container { text-align: center; }
                                                                        #tetris-canvas { border: 2px solid black; background: #fff; display:block; margin: 0 auto; }
                                                                        #tetris-controls { display:flex; gap:8px; justify-content:center; margin-top:8px; }
                                                                        #tetris-controls button { padding:8px 12px; font-size:14px; }
                                                                    </style>
                                                                    <div id="tetris-container">
                                                                        <h3 id="gameTitle">Tetris</h3>
                                                                        <canvas id="tetris-canvas" width="240" height="400"></canvas>
                                                                        <div id="tetris-score">Score: <span id="tetris-score-value">0</span></div>
                                                                        <div id="tetris-controls">
                                                                            <button id="tetris-start">Start/Pause</button>
                                                                            <button id="tetris-left">‚Üê</button>
                                                                            <button id="tetris-up">‚Üë</button>
                                                                            <button id="tetris-right">‚Üí</button>
                                                                            <button id="tetris-down">‚Üì</button>
                                                                        </div>
                                                                    </div>
                                                            `;

                                                            const canvas = document.getElementById('tetris-canvas');
                                                            const context = canvas.getContext('2d');
                                                            const scoreElement = document.getElementById('tetris-score-value');
                                                            const startButton = document.getElementById('tetris-start');
                                                            const leftButton = document.getElementById('tetris-left');
                                                            const rightButton = document.getElementById('tetris-right');
                                                            const upButton = document.getElementById('tetris-up');
                                                            const downButton = document.getElementById('tetris-down');

                                                            context.scale(20,20);
                                                            const GRID_WIDTH = 12; const GRID_HEIGHT = 20;
                                                            const grid = Array.from({length: GRID_HEIGHT},()=>Array(GRID_WIDTH).fill(0));
                                                            let score = 0; let gameLoopInterval = null; let isPaused = true;

                                                            const SHAPES = [ [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]], [[0,1,1],[1,1,0]], [[1,1,0],[0,1,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]] ];
                                                            const COLORS = ['cyan','yellow','purple','green','red','blue','orange'];
                                                            let currentPiece = null;

                                                            function createPiece(){ const idx = Math.floor(Math.random()*SHAPES.length); return { shape: SHAPES[idx], color: COLORS[idx], x: Math.floor(GRID_WIDTH/2) - Math.floor(SHAPES[idx][0].length/2), y: 0 }; }
                                                            function draw(){ context.fillStyle = '#fff'; context.fillRect(0,0,canvas.width/20, canvas.height/20); for(let y=0;y<GRID_HEIGHT;y++){ for(let x=0;x<GRID_WIDTH;x++){ if(grid[y][x]){ context.fillStyle = grid[y][x]; context.fillRect(x,y,1,1); } } } if(currentPiece){ context.fillStyle = currentPiece.color; currentPiece.shape.forEach((row,dy)=>{ row.forEach((v,dx)=>{ if(v) context.fillRect(currentPiece.x+dx, currentPiece.y+dy,1,1); }); }); }
                                                            }

                                                            function collide(piece){ for(let y=0;y<piece.shape.length;y++){ for(let x=0;x<piece.shape[y].length;x++){ if(piece.shape[y][x]){ const nx = piece.x+x; const ny = piece.y+y; if(nx<0||nx>=GRID_WIDTH||ny>=GRID_HEIGHT||(ny>=0&&grid[ny][nx])) return true; } } } return false; }

                                                            function merge(){ currentPiece.shape.forEach((row,dy)=>{ row.forEach((v,dx)=>{ if(v) grid[currentPiece.y+dy][currentPiece.x+dx]=currentPiece.color; }); }); }

                                                            function clearLines(){ let linesCleared=0; for(let y=GRID_HEIGHT-1;y>=0;y--){ if(grid[y].every(cell=>cell!==0)){ grid.splice(y,1); grid.unshift(Array(GRID_WIDTH).fill(0)); linesCleared++; y++; } } if(linesCleared){ score+=linesCleared*100; scoreElement.textContent = score; } }

                                                            function moveDown(){ currentPiece.y++; if(collide(currentPiece)){ currentPiece.y--; merge(); clearLines(); currentPiece=createPiece(); if(collide(currentPiece)){ grid.forEach(row=>row.fill(0)); score=0; scoreElement.textContent=score; } } draw(); }

                                                            function rotate(){ const original = currentPiece.shape; const newShape = original[0].map((_,i)=> original.map(row=>row[i]).reverse()); currentPiece.shape = newShape; if(collide(currentPiece)) currentPiece.shape=original; }

                                                            function move(side){ currentPiece.x+=side; if(collide(currentPiece)) currentPiece.x-=side; }

                                                            function updateControlButtons(){ leftButton.disabled=isPaused; rightButton.disabled=isPaused; upButton.disabled=isPaused; downButton.disabled=isPaused; }

                                                            document.addEventListener('keydown', tetrisKeyHandler);
                                                            function tetrisKeyHandler(e){ if(!isPaused){ if(e.key==='ArrowLeft') move(-1); else if(e.key==='ArrowRight') move(1); else if(e.key==='ArrowDown') moveDown(); else if(e.key==='ArrowUp') rotate(); draw(); } }

                                                            leftButton.addEventListener('click',()=>{ if(!isPaused){ move(-1); draw(); } });
                                                            rightButton.addEventListener('click',()=>{ if(!isPaused){ move(1); draw(); } });
                                                            upButton.addEventListener('click',()=>{ if(!isPaused){ rotate(); draw(); } });
                                                            downButton.addEventListener('click',()=>{ if(!isPaused){ moveDown(); draw(); } });

                                                            startButton.addEventListener('click', ()=>{ isPaused=!isPaused; startButton.textContent = isPaused ? 'Start' : 'Pause'; updateControlButtons(); if(!isPaused && !gameLoopInterval) gameLoopInterval = setInterval(moveDown, 800); else if(isPaused && gameLoopInterval){ clearInterval(gameLoopInterval); gameLoopInterval=null; } });

                                                            // initialize piece and draw
                                                            currentPiece = createPiece(); updateControlButtons(); draw();

                                                            activeGameCleanup = function(){ try{ document.removeEventListener('keydown', tetrisKeyHandler); leftButton.removeEventListener('click', ()=>{}); rightButton.removeEventListener('click', ()=>{}); upButton.removeEventListener('click', ()=>{}); downButton.removeEventListener('click', ()=>{}); startButton.removeEventListener('click', ()=>{}); if(gameLoopInterval) clearInterval(gameLoopInterval); }catch(e){ console.error('tetris cleanup', e); } activeGameCleanup = null; };
                                                    }

        function loadSimonGame() {
            modalBody.innerHTML = `
                <style>
                    body{background:#222;color:#fff;font-family:Arial, sans-serif}
                    #simon-wrapper{padding:10px;text-align:center}
                    #simon-board{display:grid;grid-template-columns:repeat(2,150px);grid-gap:20px;justify-content:center}
                    .simon-btn{width:150px;height:150px;border-radius:10px;opacity:.95;cursor:pointer;display:flex;align-items:center;justify-content:center;border:4px solid #111}
                    .simon-btn.red{background: linear-gradient(135deg,#ff4d4d,#b30000)}
                    .simon-btn.blue{background: linear-gradient(135deg,#4da6ff,#003d99)}
                    .simon-btn.green{background: linear-gradient(135deg,#66ff66,#117700)}
                    .simon-btn.yellow{background: linear-gradient(135deg,#fff066,#b38f00)}
                    .simon-btn.flash{opacity:1; box-shadow: 0 0 30px rgba(255,255,255,0.9), 0 0 60px rgba(255,255,255,0.2); transform: scale(1.03);}
                    #simon-controls{margin-top:12px}
                    #simon-message{margin-top:8px;color:#ffcccb}
                </style>
                <div id="simon-wrapper">
                    <h3 id="gameTitle">Simon Says</h3>
                    <div id="simon-score">Score: 0</div>
                    <div id="simon-highscore">High Score: 0</div>
                    <select id="simon-difficulty">
                      <option value="easy">Easy</option>
                      <option value="medium" selected>Medium</option>
                      <option value="hard">Hard</option>
                    </select>
                    <div id="simon-board">
                        <div class="simon-btn red" id="simon-red"></div>
                        <div class="simon-btn blue" id="simon-blue"></div>
                        <div class="simon-btn green" id="simon-green"></div>
                        <div class="simon-btn yellow" id="simon-yellow"></div>
                    </div>
                    <div id="simon-controls">
                        <button id="simon-start">Start Game</button>
                        <div id="simon-message"></div>
                    </div>
                    <audio id="simon-sound-red" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg"></audio>
                    <audio id="simon-sound-blue" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg"></audio>
                    <audio id="simon-sound-green" src="https://actions.google.com/sounds/v1/cartoon/boing.ogg"></audio>
                    <audio id="simon-sound-yellow" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg"></audio>
                </div>
            `;

            // State
            const colors = ["red","blue","green","yellow"];
            let sequence = [];
            let playerSequence = [];
            let score = 0;
            let highscore = parseInt(localStorage.getItem('simon-highscore'))||0;
            let acceptingInput = false;
            let speed = 700;
            let growth = 1;

            // Elements
            const scoreEl = document.getElementById('simon-score');
            const highEl = document.getElementById('simon-highscore');
            const messageEl = document.getElementById('simon-message');
            const startBtn = document.getElementById('simon-start');
            const diffSel = document.getElementById('simon-difficulty');

            highEl.textContent = `High Score: ${highscore}`;

            // Handlers
            function setDifficulty(){ const lvl = diffSel.value; if(lvl==='easy'){ speed=1000; growth=1 } else if(lvl==='medium'){ speed=700; growth=1 } else { speed=500; growth=2 } }

            function flashButton(color){ const el = document.getElementById('simon-'+color); if(!el) return; el.classList.add('flash'); setTimeout(()=>el.classList.remove('flash'),300); }
            function playSound(color){ const s = document.getElementById('simon-sound-'+color); if(s) s.play(); }

            function handlePlayerInput(color){ if(!acceptingInput) return; playerSequence.push(color); flashButton(color); playSound(color); const idx = playerSequence.length-1; if(playerSequence[idx] !== sequence[idx]){ messageEl.textContent='‚ùå Wrong! Game Over.'; acceptingInput=false; return; } if(playerSequence.length===sequence.length){ score++; scoreEl.textContent=`Score: ${score}`; if(score>highscore){ highscore=score; localStorage.setItem('simon-highscore', highscore); highEl.textContent=`High Score: ${highscore}` } setTimeout(nextRound,1000); } }

            // Attach color buttons
            function onColorClickFactory(color){ return ()=>handlePlayerInput(color); }
            const colorHandlers = {};
            colors.forEach(c=>{ const id='simon-'+c; colorHandlers[c]=onColorClickFactory(c); document.getElementById(id).addEventListener('click', colorHandlers[c]); });

            // Game flow
            function startGame(){ setDifficulty(); sequence=[]; playerSequence=[]; score=0; acceptingInput=false; scoreEl.textContent='Score: 0'; messageEl.textContent=''; nextRound(); }
            function nextRound(){ acceptingInput=false; playerSequence=[]; for(let i=0;i<growth;i++){ sequence.push(colors[Math.floor(Math.random()*colors.length)]); } playSequence(); }
            function playSequence(){ let i=0; const iv=setInterval(()=>{ const col=sequence[i]; flashButton(col); playSound(col); i++; if(i>=sequence.length){ clearInterval(iv); acceptingInput=true; } }, speed); }

            // Wire start and difficulty
            startBtn.addEventListener('click', startGame);
            diffSel.addEventListener('change', setDifficulty);

            // Expose cleanup to activeGameCleanup
            activeGameCleanup = function(){ try{ startBtn.removeEventListener('click', startGame); diffSel.removeEventListener('change', setDifficulty); colors.forEach(c=>{ const id='simon-'+c; const h = colorHandlers[c]; if(h) document.getElementById(id).removeEventListener('click', h); }); }catch(e){ console.error('simon cleanup', e); } activeGameCleanup=null; };
        }

                function loadLightsOutGame(){
                        modalBody.innerHTML = `
                                <style>
                                    /* Keep the lights-out styles self-contained so site styles don't interfere */
                                    :root{ --bg:#141414; --card:#1f1f2b; }
                                    .lo-container{padding:18px; color:#eee; font-family:system-ui,Arial, sans-serif}
                                    .lo-controls{display:flex;gap:8px;justify-content:center;align-items:center;flex-wrap:wrap;margin-bottom:12px}
                                    .lo-controls select,.lo-controls button{padding:8px 12px;border-radius:6px;border:none;cursor:pointer}
                                    .lo-primary{background:#0ea5a5;color:#031016;font-weight:600}
                                    .lo-secondary{background:#333;color:#fff}
                                    #lo-game-board{display:grid;grid-template-columns:repeat(5,60px);grid-gap:10px;justify-content:center;margin:18px auto 8px}
                                    .lo-cell{width:60px;height:60px;background:#333;border-radius:8px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 2px 0 rgba(0,0,0,0.6);cursor:pointer;transition:transform .12s,background-color .22s,box-shadow .22s}
                                    .lo-cell.on{background:linear-gradient(180deg,#fff176,#ffd54a);box-shadow:0 6px 18px rgba(255,215,64,0.28),inset 0 1px 0 rgba(255,255,255,0.6)}
                                    #lo-stats{margin-top:10px;font-size:14px;color:#cfe8e8}
                                    #lo-highscores{margin-top:8px;font-size:13px;color:#c7e3e3}
                                    @media(max-width:420px){ #lo-game-board{grid-template-columns:repeat(5,50px);grid-gap:8px} .lo-cell{width:50px;height:50px} }
                                </style>
                                <div class="lo-container">
                                    <h3 id="gameTitle">Lights Out</h3>
                                    <div class="lo-controls">
                                        <label class="small">Difficulty</label>
                                        <select id="lo-difficulty">
                                            <option value="easy">Easy</option>
                                            <option value="medium" selected>Medium</option>
                                            <option value="hard">Hard</option>
                                        </select>
                                        <button id="lo-start" class="lo-primary">Start Game</button>
                                        <button id="lo-reset" class="lo-secondary">Reset Saved Progress</button>
                                    </div>
                                    <div id="lo-stats">Moves: <span id="lo-moveCount">0</span> | Time: <span id="lo-timer">0</span>s</div>
                                    <div id="lo-highscores">Best Moves: <span id="lo-bestMoves">-</span> | Fastest Time: <span id="lo-bestTime">-</span></div>
                                    <div id="lo-game-board" aria-live="polite"></div>
                                    <audio id="lo-clickSound" src="https://www.soundjay.com/button/sounds/button-16.mp3" preload="auto"></audio>
                                </div>
                        `;

                        // Elements
                        const boardSize = 5;
                        const boardElLO = document.getElementById('lo-game-board');
                        const difficultyElLO = document.getElementById('lo-difficulty');
                        const moveCountElLO = document.getElementById('lo-moveCount');
                        const timerElLO = document.getElementById('lo-timer');
                        const bestMovesElLO = document.getElementById('lo-bestMoves');
                        const bestTimeElLO = document.getElementById('lo-bestTime');
                        const clickSoundLO = document.getElementById('lo-clickSound');
                        const startBtnLO = document.getElementById('lo-start');
                        const resetBtnLO = document.getElementById('lo-reset');

                        // State
                        let moveCount = 0;
                        let seconds = 0;
                        let timerInterval = null;

                        const PROGRESS_KEY = 'lightsOutProgress';
                        const HS_PREFIX = 'lightsOutHighScore_';

                        function createBoardLO(){ boardElLO.innerHTML=''; for(let r=0;r<boardSize;r++){ for(let c=0;c<boardSize;c++){ const btn=document.createElement('button'); btn.className='lo-cell'; btn.dataset.row=r; btn.dataset.col=c; btn.type='button'; btn.addEventListener('click', loHandleCellClick); boardElLO.appendChild(btn); } } }

                        function toggleLightsLO(r,c, playSound=false, saveAfter=true){ const deltas=[[0,0],[-1,0],[1,0],[0,-1],[0,1]]; deltas.forEach(([dr,dc])=>{ const rr=r+dr, cc=c+dc; if(rr>=0 && rr<boardSize && cc>=0 && cc<boardSize){ const idx=rr*boardSize+cc; const cell=boardElLO.children[idx]; cell.classList.toggle('on'); } }); if(playSound){ try{ clickSoundLO.currentTime=0; clickSoundLO.play(); }catch(e){} } if(saveAfter) saveProgressLO(); }

                        function loHandleCellClick(e){ const r=Number(e.currentTarget.dataset.row); const c=Number(e.currentTarget.dataset.col); toggleLightsLO(r,c,true,true); moveCount++; moveCountElLO.textContent=moveCount; ensureTimerRunningLO(); checkWinLO(); }

                        function randomizeBoardLO(level){ const flips = level==='easy'?3:level==='medium'?6:10; for(let i=0;i<flips;i++){ const r=Math.floor(Math.random()*boardSize); const c=Math.floor(Math.random()*boardSize); toggleLightsLO(r,c,false,false); } saveProgressLO(); }

                        function ensureTimerRunningLO(){ if(timerInterval) return; timerInterval = setInterval(()=>{ seconds++; timerElLO.textContent = seconds; saveProgressLO(); },1000); }
                        function stopTimerLO(){ if(timerInterval){ clearInterval(timerInterval); timerInterval=null; } }

                        function checkWinLO(){ const allOff = Array.from(boardElLO.children).every(c=>!c.classList.contains('on')); if(allOff){ stopTimerLO(); const currentSeconds = seconds; const currentMoves = moveCount; setTimeout(()=>alert(`You won in ${currentMoves} moves and ${currentSeconds} seconds!`),80); updateHighScoresLO(); localStorage.removeItem(PROGRESS_KEY); } }

                        function saveProgressLO(){ try{ const cells = Array.from(boardElLO.children).map(c=> c.classList.contains('on')?1:0); const payload = { cells, moveCount, seconds, difficulty: difficultyElLO.value }; localStorage.setItem(PROGRESS_KEY, JSON.stringify(payload)); }catch(e){} }

                        function loadProgressLO(){ const raw = localStorage.getItem(PROGRESS_KEY); if(!raw) return false; try{ const {cells, moveCount:mc, seconds:s, difficulty} = JSON.parse(raw); if(!Array.isArray(cells) || cells.length !== boardSize*boardSize) return false; difficultyElLO.value = difficulty || difficultyElLO.value; moveCount = Number.isInteger(mc)?mc:0; seconds = Number.isInteger(s)?s:0; moveCountElLO.textContent = moveCount; timerElLO.textContent = seconds; createBoardLO(); cells.forEach((v,i)=>{ if(v===1) boardElLO.children[i].classList.add('on'); else boardElLO.children[i].classList.remove('on'); }); ensureTimerRunningLO(); loadHighScoresLO(difficultyElLO.value); return true; }catch(e){ return false; } }

                        function highScoreKeyLO(level){ return HS_PREFIX + level; }
                        function updateHighScoresLO(){ const level = difficultyElLO.value; const key = highScoreKeyLO(level); const prev = JSON.parse(localStorage.getItem(key)) || { moves: Infinity, time: Infinity }; const better = (moveCount < prev.moves) || (moveCount === prev.moves && seconds < prev.time); if(better){ const record = { moves: moveCount, time: seconds }; try{ localStorage.setItem(key, JSON.stringify(record)); }catch(e){} } loadHighScoresLO(level); }
                        function loadHighScoresLO(level){ const key = highScoreKeyLO(level); const saved = JSON.parse(localStorage.getItem(key)); bestMovesElLO.textContent = saved && isFinite(saved.moves) ? saved.moves : '-'; bestTimeElLO.textContent = saved && isFinite(saved.time) ? saved.time : '-'; }

                        function startGameLO(){ stopTimerLO(); moveCount = 0; seconds = 0; moveCountElLO.textContent = '0'; timerElLO.textContent = '0'; createBoardLO(); const level = difficultyElLO.value; randomizeBoardLO(level); loadHighScoresLO(level); ensureTimerRunningLO(); }

                        function resetSavedProgressLO(){ stopTimerLO(); localStorage.removeItem(PROGRESS_KEY); moveCount = 0; seconds = 0; moveCountElLO.textContent = '0'; timerElLO.textContent = '0'; createBoardLO(); loadHighScoresLO(difficultyElLO.value); }

                        // Named handlers for cleanup
                        startBtnLO.addEventListener('click', startGameLO);
                        resetBtnLO.addEventListener('click', resetSavedProgressLO);
                        difficultyElLO.addEventListener('change', ()=> loadHighScoresLO(difficultyElLO.value));

                        // Init
                        createBoardLO(); const hadProgress = loadProgressLO(); if(!hadProgress) { loadHighScoresLO(difficultyElLO.value); }

                        // Focus start button for accessibility
                        startBtnLO.focus();

                        // Cleanup
                        activeGameCleanup = function(){ try{ startBtnLO.removeEventListener('click', startGameLO); resetBtnLO.removeEventListener('click', resetSavedProgressLO); difficultyElLO.removeEventListener('change', ()=> loadHighScoresLO(difficultyElLO.value)); // remove cell handlers
                                Array.from(boardElLO.children).forEach(btn=> btn.removeEventListener('click', loHandleCellClick)); stopTimerLO(); }catch(e){ console.error('lights-out cleanup', e); } activeGameCleanup = null; };
                }

                            function loadFifteenGame(){
                                    modalBody.innerHTML = `
                                            <style>
                                                :root{ --bg:#0f1724; --panel:#0b1320; --tile:#1f2937; --tile-lit:#f59e0b; --text:#e6eef6; --accent:#06b6d4 }
                                                .f15-container{padding:18px;color:var(--text);font-family:system-ui,Arial, sans-serif}
                                                .f15-controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:12px}
                                                .f15-controls select, .f15-controls button{padding:8px 12px;border-radius:8px;border:none;background:#0b1220;color:var(--text);cursor:pointer;font-weight:600}
                                                .f15-primary{background:var(--accent);color:#022025}
                                                .f15-board-wrap{display:flex;gap:18px;align-items:flex-start;justify-content:center;flex-wrap:wrap}
                                                .f15-board{width:360px;height:360px;display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr);gap:10px;padding:10px;border-radius:10px;background:linear-gradient(180deg,#071426,#071427)}
                                                .f15-tile{display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:700;color:#fff;border-radius:8px;background:linear-gradient(180deg,var(--tile),#111827);box-shadow:0 6px 12px rgba(2,6,23,0.6);user-select:none;cursor:pointer;transition:transform .12s ease, background .12s}
                                                .f15-tile.empty{background:transparent;box-shadow:none;cursor:default}
                                                .f15-tile.correct{background:linear-gradient(180deg,#10b981,#06b6d4);color:#05201c}
                                                .f15-meta{display:flex;flex-direction:column;gap:10px;min-width:120px}
                                                .f15-stat{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;text-align:center;font-size:14px}
                                                .f15-footer{margin-top:12px;text-align:center;font-size:13px;color:#bcdedd}
                                                @media(max-width:520px){ .f15-board{width:300px;height:300px} .f15-tile{font-size:24px} }
                                            </style>
                                            <div class="f15-container">
                                                <h3 id="gameTitle">15 Puzzle</h3>
                                                <div class="f15-controls">
                                                    <select id="f15-preset">
                                                        <option value="solved">Solved</option>
                                                        <option value="easy">Easy (100 shuffles)</option>
                                                        <option value="medium" selected>Medium (400 shuffles)</option>
                                                        <option value="hard">Hard (1200 shuffles)</option>
                                                    </select>
                                                    <button id="f15-shuffle" class="f15-primary">Shuffle</button>
                                                    <button id="f15-solve">Solve (reset)</button>
                                                    <button id="f15-save">Save</button>
                                                    <button id="f15-load">Load</button>
                                                </div>
                                                <div class="f15-board-wrap">
                                                    <div id="f15-board" class="f15-board" tabindex="0" aria-label="puzzle board"></div>
                                                    <div class="f15-meta">
                                                        <div class="f15-stat">Moves<br><strong id="f15-moves">0</strong></div>
                                                        <div class="f15-stat">Time<br><strong id="f15-time">0s</strong></div>
                                                        <div class="f15-stat">Status<br><strong id="f15-status">Playing</strong></div>
                                                        <div class="f15-hint">Controls: click tile or use arrow keys to move tile into empty space.</div>
                                                    </div>
                                                </div>
                                                <div class="f15-footer">Shuffle produces only solvable positions; winning highlights correct tiles.</div>
                                            </div>
                                    `;

                                    // Elements
                                    const SIZE = 4; const TOTAL = SIZE*SIZE;
                                    const boardElF = document.getElementById('f15-board');
                                    const movesElF = document.getElementById('f15-moves');
                                    const timeElF = document.getElementById('f15-time');
                                    const statusElF = document.getElementById('f15-status');
                                    const shuffleBtnF = document.getElementById('f15-shuffle');
                                    const solveBtnF = document.getElementById('f15-solve');
                                    const presetElF = document.getElementById('f15-preset');
                                    const saveBtnF = document.getElementById('f15-save');
                                    const loadBtnF = document.getElementById('f15-load');

                                    let tiles = []; let emptyIndex = TOTAL-1; let moveCount = 0; let seconds = 0; let timerInt = null;
                                    const STORAGE_KEY = 'fifteenPuzzle_v1';

                                    function createBoardDOMF(){ boardElF.innerHTML=''; for(let i=0;i<TOTAL;i++){ const el=document.createElement('div'); el.className='f15-tile'; el.setAttribute('data-index', i); el.addEventListener('click', onTileClickF); boardElF.appendChild(el); } }

                                    function renderF(){ for(let i=0;i<TOTAL;i++){ const el=boardElF.children[i]; const v=tiles[i]; if(v===0){ el.textContent=''; el.classList.add('empty'); el.classList.remove('correct'); el.setAttribute('aria-label','empty'); } else { el.textContent=v; el.classList.remove('empty'); const correct = (v === i+1); el.classList.toggle('correct', correct); el.setAttribute('aria-label','tile '+v); } } movesElF.textContent = moveCount; timeElF.textContent = seconds + 's'; }

                                    function setSolvedF(){ tiles = Array.from({length:TOTAL}, (_,i)=>i+1); tiles[TOTAL-1]=0; emptyIndex = TOTAL-1; }

                                    function canMoveF(index){ const r1=Math.floor(index/SIZE), c1=index%SIZE; const r0=Math.floor(emptyIndex/SIZE), c0=emptyIndex%SIZE; const dr=Math.abs(r1-r0), dc=Math.abs(c1-c0); return (dr+dc)===1; }

                                    function moveTileF(index, record=true){ if(!canMoveF(index)) return false; tiles[emptyIndex]=tiles[index]; tiles[index]=0; emptyIndex=index; if(record){ moveCount++; startTimerF(); saveProgressAutosF(); } renderF(); if(checkWinF()){ handleWinF(); } return true; }

                                    function onTileClickF(e){ const idx = Number(e.currentTarget.dataset.index); moveTileF(idx, true); }

                                    function shuffleF(steps){ setSolvedF(); for(let i=0;i<steps;i++){ const neighbors=[]; const r=Math.floor(emptyIndex/SIZE), c=emptyIndex%SIZE; if(r>0) neighbors.push(emptyIndex - SIZE); if(r<SIZE-1) neighbors.push(emptyIndex + SIZE); if(c>0) neighbors.push(emptyIndex - 1); if(c<SIZE-1) neighbors.push(emptyIndex + 1); const choice = neighbors[Math.floor(Math.random()*neighbors.length)]; tiles[emptyIndex]=tiles[choice]; tiles[choice]=0; emptyIndex=choice; } moveCount=0; seconds=0; stopTimerF(); renderF(); statusElF.textContent='Playing'; saveProgressAutosF(); }

                                    function checkWinF(){ for(let i=0;i<TOTAL-1;i++){ if(tiles[i] !== i+1) return false; } return tiles[TOTAL-1]===0; }

                                    function handleWinF(){ stopTimerF(); statusElF.textContent='Solved!'; for(let i=0;i<TOTAL;i++){ const el = boardElF.children[i]; if(tiles[i] !== 0) el.classList.add('correct'); } const level = presetElF.value; try{ const key = STORAGE_KEY + '_best_' + level; const prev = JSON.parse(localStorage.getItem(key)) || null; const current = {moves: moveCount, time: seconds, when: Date.now()}; let better = false; if(!prev) better = true; else if(current.moves < prev.moves) better = true; else if(current.moves === prev.moves && current.time < prev.time) better = true; if(better){ localStorage.setItem(key, JSON.stringify(current)); statusElF.textContent = 'New best!'; } }catch(e){} saveProgressAutosF(true); }

                                    function startTimerF(){ if(timerInt) return; timerInt = setInterval(()=>{ seconds++; timeElF.textContent = seconds + 's'; saveProgressAutosF(); },1000); }
                                    function stopTimerF(){ if(timerInt){ clearInterval(timerInt); timerInt=null; } }

                                    function onKeyF(e){ let target=null; const r=Math.floor(emptyIndex/SIZE), c=emptyIndex%SIZE; if(e.key==='ArrowUp'){ if(r < SIZE - 1) target = emptyIndex + SIZE; } else if(e.key==='ArrowDown'){ if(r > 0) target = emptyIndex - SIZE; } else if(e.key==='ArrowLeft'){ if(c < SIZE - 1) target = emptyIndex + 1; } else if(e.key==='ArrowRight'){ if(c > 0) target = emptyIndex - 1; } else return; e.preventDefault(); if(target !== null) moveTileF(target, true); }

                                    function saveProgressAutosF(clear=false){ try{ if(clear){ localStorage.removeItem(STORAGE_KEY); return; } const payload = {tiles, emptyIndex, moveCount, seconds, preset: presetElF.value}; localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); }catch(e){} }

                                    function manualSaveF(){ try{ const payload = {tiles, emptyIndex, moveCount, seconds, preset: presetElF.value, savedAt: Date.now()}; localStorage.setItem(STORAGE_KEY + '_manual', JSON.stringify(payload)); statusElF.textContent = 'Saved'; setTimeout(()=>{ if(statusElF.textContent === 'Saved') statusElF.textContent = 'Playing'; }, 1200); }catch(e){} }

                                    function manualLoadF(){ try{ const raw = localStorage.getItem(STORAGE_KEY + '_manual'); if(!raw) return; const p = JSON.parse(raw); if(Array.isArray(p.tiles) && p.tiles.length === TOTAL){ tiles = p.tiles.slice(); emptyIndex = p.emptyIndex; moveCount = Number(p.moveCount) || 0; seconds = Number(p.seconds) || 0; presetElF.value = p.preset || presetElF.value; renderF(); movesElF.textContent = moveCount; timeElF.textContent = seconds + 's'; startTimerF(); statusElF.textContent = 'Loaded'; setTimeout(()=>{ if(statusElF.textContent === 'Loaded') statusElF.textContent = 'Playing'; }, 900); } }catch(e){} }

                                    function tryLoadAutoF(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return false; const p = JSON.parse(raw); if(Array.isArray(p.tiles) && p.tiles.length === TOTAL){ tiles = p.tiles.slice(); emptyIndex = p.emptyIndex; moveCount = Number(p.moveCount) || 0; seconds = Number(p.seconds) || 0; presetElF.value = p.preset || presetElF.value; renderF(); movesElF.textContent = moveCount; timeElF.textContent = seconds + 's'; startTimerF(); statusElF.textContent = 'Playing'; return true; } }catch(e){} return false; }

                                    // UI wiring (named handlers)
                                    function shuffleBtnHandler(){ const level = presetElF.value; const steps = level === 'easy' ? 100 : level === 'medium' ? 400 : 1200; shuffleF(steps); }
                                    function solveBtnHandler(){ setSolvedF(); moveCount = 0; seconds = 0; stopTimerF(); renderF(); statusElF.textContent = 'Solved (reset)'; saveProgressAutosF(true); }
                                    function saveBtnHandler(){ manualSaveF(); }
                                    function loadBtnHandler(){ manualLoadF(); }

                                    // Attach
                                    shuffleBtnF.addEventListener('click', shuffleBtnHandler);
                                    solveBtnF.addEventListener('click', solveBtnHandler);
                                    saveBtnF.addEventListener('click', saveBtnHandler);
                                    loadBtnF.addEventListener('click', loadBtnHandler);

                                    // init
                                    createBoardDOMF(); if(!tryLoadAutoF()){ setSolvedF(); renderF(); }
                                    boardElF.addEventListener('keydown', onKeyF);
                                    window.addEventListener('keydown', onKeyF);
                                    boardElF.tabIndex = 0; boardElF.focus();

                                    // cleanup
                                    activeGameCleanup = function(){ try{ shuffleBtnF.removeEventListener('click', shuffleBtnHandler); solveBtnF.removeEventListener('click', solveBtnHandler); saveBtnF.removeEventListener('click', saveBtnHandler); loadBtnF.removeEventListener('click', loadBtnHandler); boardElF.removeEventListener('keydown', onKeyF); window.removeEventListener('keydown', onKeyF); Array.from(boardElF.children).forEach(el=> el.removeEventListener('click', onTileClickF)); stopTimerF(); }catch(e){ console.error('15-puzzle cleanup', e); } activeGameCleanup = null; };
                            }

                                        function loadNonogramGame(){
                                                modalBody.innerHTML = `
                                                        <style>
                                                            :root{ --bg:#0f1724; --panel:#0b1220; --accent:#06b6d4; --tile:#e6eef6; --mark:#111827; --filled:#111827; --xmark:#ef4444; }
                                                            .no-wrap{max-width:980px;margin:28px auto;padding:18px;background:linear-gradient(180deg,var(--panel),#071421);border-radius:12px}
                                                            header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
                                                            .controls select,.controls button{padding:8px 10px;border-radius:8px;border:none;background:#07262a;color:var(--tile);cursor:pointer;font-weight:600}
                                                            .controls button.primary{background:var(--accent);color:#012226}
                                                            .board-area{display:flex;gap:16px;margin-top:16px;align-items:flex-start;flex-wrap:wrap}
                                                            .clues{display:grid;gap:4px;color:#a8c6ca;font-size:13px}
                                                            .grid-wrap{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px}
                                                            .grid{display:grid;gap:2px;background:transparent;border:6px solid transparent}
                                                            .cell{width:32px;height:32px;display:flex;align-items:center;justify-content:center;background:#0c1620;border-radius:6px;cursor:pointer;user-select:none;font-weight:700;color:transparent;transition:background .12s, transform .08s}
                                                            .cell:hover{transform:translateY(-2px)}
                                                            .cell.filled{background:var(--filled);color:var(--tile)}
                                                            .cell.xmark{background:transparent;color:var(--xmark);border:1px dashed rgba(255,255,255,0.04)}
                                                            .sidebar{min-width:220px;display:flex;flex-direction:column;gap:10px}
                                                            .stat{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;font-size:13px}
                                                        </style>
                                                        <div class="no-wrap" role="application" aria-label="Nonogram game">
                                                            <header>
                                                                <h3>Nonogram (Picross)</h3>
                                                                <div class="controls">
                                                                    <select id="no-puzzleSelect">
                                                                        <option value="heart">Heart 10x10</option>
                                                                        <option value="smiley">Smiley 10x10</option>
                                                                        <option value="cat">Cat 12x12</option>
                                                                    </select>
                                                                    <button id="no-newBtn" class="primary">New Puzzle</button>
                                                                    <button id="no-checkBtn">Check</button>
                                                                    <button id="no-solveBtn">Solve</button>
                                                                    <button id="no-saveBtn">Save</button>
                                                                    <button id="no-loadBtn">Load</button>
                                                                </div>
                                                            </header>
                                                            <div class="board-area">
                                                                <div class="grid-wrap" id="no-gridWrap" aria-live="polite"></div>
                                                                <div class="sidebar" aria-hidden>
                                                                    <div class="stat">Mode: <strong id="no-modeLabel">Fill</strong></div>
                                                                    <div class="stat">Moves: <strong id="no-moves">0</strong></div>
                                                                    <div class="stat">Time: <strong id="no-timer">0s</strong></div>
                                                                    <div class="stat">Hint: Click cell to cycle Fill ‚Üí X ‚Üí Clear. Right-click to reverse cycle.</div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                `;

                                                // puzzles (copied from original)
                                                const puzzlesLocal = {
                                                    heart: { rows:10, cols:10, solution:["0011111100","0111111110","1111111111","1111111111","1111111111","0111111110","0011111100","0001110000","0000100000","0000000000"] },
                                                    smiley: { rows:10, cols:10, solution:["0001111100","0010000010","0101100110","0100000010","0100000010","0101100110","0010000010","0001111100","0000000000","0000000000"] },
                                                    cat: { rows:12, cols:12, solution:["000011110000","000111111000","001111111100","011101110110","011111111110","011111111110","011111111110","001111111100","000111011000","000011110000","000000000000","000000000000"] }
                                                };

                                                // DOM refs
                                                const gridWrapNo = document.getElementById('no-gridWrap');
                                                const puzzleSelectNo = document.getElementById('no-puzzleSelect');
                                                const newBtnNo = document.getElementById('no-newBtn');
                                                const checkBtnNo = document.getElementById('no-checkBtn');
                                                const solveBtnNo = document.getElementById('no-solveBtn');
                                                const saveBtnNo = document.getElementById('no-saveBtn');
                                                const loadBtnNo = document.getElementById('no-loadBtn');
                                                const movesElNo = document.getElementById('no-moves');
                                                const timerElNo = document.getElementById('no-timer');
                                                const modeLabelNo = document.getElementById('no-modeLabel');

                                                let stateNo = { puzzleId:'heart', rows:10, cols:10, cells:[], moves:0, seconds:0, timerInt:null };

                                                function computeClues(sol){ const rows = sol.length; const cols = sol[0].length; const rowClues = sol.map(r=>{ const parts = r.match(/1+/g) || []; return parts.map(p=>p.length); }); const colClues=[]; for(let c=0;c<cols;c++){ let colStr=''; for(let r=0;r<rows;r++) colStr += sol[r][c]; const parts = colStr.match(/1+/g) || []; colClues.push(parts.map(p=>p.length)); } return {rowClues, colClues}; }

                                                function initPuzzleNo(id){ const p = puzzlesLocal[id]; stateNo.puzzleId = id; stateNo.rows = p.rows; stateNo.cols = p.cols; const {rowClues, colClues} = computeClues(p.solution); stateNo.rowClues = rowClues; stateNo.colClues = colClues; stateNo.cells = new Array(p.rows * p.cols).fill(0); stateNo.moves = 0; stateNo.seconds = 0; stopTimerNo(); renderNo(); saveAutosNo(); }

                                                function renderNo(){ gridWrapNo.innerHTML=''; const colClueArea = document.createElement('div'); colClueArea.className='clues clue-col'; colClueArea.style.display='grid'; colClueArea.style.gridTemplateColumns = `repeat(${stateNo.cols}, 32px)`; const maxColClues = Math.max(...stateNo.colClues.map(c=>c.length)); for(let c=0;c<stateNo.cols;c++){ const wrapper = document.createElement('div'); wrapper.style.display='flex'; wrapper.style.flexDirection='column'; wrapper.style.alignItems='center'; wrapper.style.justifyContent='flex-end'; wrapper.style.height = `${maxColClues*22}px`; const clues = stateNo.colClues[c].slice().reverse(); for(let i=0;i<maxColClues;i++){ const span = document.createElement('span'); span.style.margin='2px 0'; span.textContent = clues[i] ?? ''; wrapper.appendChild(span); } colClueArea.appendChild(wrapper); }
                                                    const rowClueArea = document.createElement('div'); rowClueArea.className='clues clue-row'; rowClueArea.style.display='grid'; rowClueArea.style.gridTemplateRows = `repeat(${stateNo.rows}, 32px)`; rowClueArea.style.rowGap='6px'; const maxRowClues = Math.max(...stateNo.rowClues.map(r=>r.length)); for(let r=0;r<stateNo.rows;r++){ const wrapper = document.createElement('div'); wrapper.style.display='flex'; wrapper.style.justifyContent='flex-end'; wrapper.style.gap='6px'; const clues = stateNo.rowClues[r].slice().reverse(); const pad = maxRowClues - clues.length; for(let i=0;i<pad;i++){ const s = document.createElement('span'); s.textContent=''; wrapper.appendChild(s); } for(let v of clues.slice().reverse()){ const s = document.createElement('span'); s.textContent = v; wrapper.appendChild(s); } rowClueArea.appendChild(wrapper); }
                                                    const board = document.createElement('div'); board.className='grid'; board.style.gridTemplateColumns = `repeat(${stateNo.cols}, 32px)`; board.style.gridTemplateRows = `repeat(${stateNo.rows}, 32px)`; board.style.width = `${stateNo.cols*34}px`; board.style.height = `${stateNo.rows*34}px`; board.tabIndex = 0; for(let i=0;i<stateNo.rows*stateNo.cols;i++){ const cell = document.createElement('div'); cell.className='cell'; cell.dataset.index = i; updateCellClassNo(cell, stateNo.cells[i]); cell.addEventListener('click', onCellClickNo); cell.addEventListener('contextmenu', e=>{ e.preventDefault(); onCellRightClickNo(e); }); board.appendChild(cell); }
                                                    const leftPane = document.createElement('div'); leftPane.style.display='flex'; leftPane.style.flexDirection='column'; leftPane.style.alignItems='center'; leftPane.appendChild(colClueArea); const middle = document.createElement('div'); middle.style.display='flex'; middle.appendChild(rowClueArea); middle.appendChild(board); leftPane.appendChild(middle); gridWrapNo.appendChild(leftPane); movesElNo.textContent = stateNo.moves; timerElNo.textContent = stateNo.seconds + 's'; modeLabelNo.textContent = currentModeLabelNo(); }

                                                function updateCellClassNo(cell, val){ cell.classList.remove('filled','xmark'); if(val === 1) cell.classList.add('filled'); else if(val === 2) cell.classList.add('xmark'); cell.textContent=''; cell.setAttribute('aria-label', val===1? 'filled' : val===2? 'x' : 'empty'); }

                                                function cycleValueNo(idx, forward=true){ const v = stateNo.cells[idx]; let next; if(forward) next = v===0?1: v===1?2:0; else next = v===0?2: v===2?1:0; stateNo.cells[idx] = next; stateNo.moves++; movesElNo.textContent = stateNo.moves; updateCellClassNo(document.querySelector(`#no-gridWrap .cell[data-index="${idx}"]`), next); startTimerNo(); saveAutosNo(); }

                                                function onCellClickNo(e){ const idx = Number(e.currentTarget.dataset.index); cycleValueNo(idx, true); }
                                                function onCellRightClickNo(e){ const idx = Number(e.currentTarget.dataset.index); cycleValueNo(idx, false); }

                                                let currentModeNo = 1; function setModeAndFillNo(val){ currentModeNo = val; modeLabelNo.textContent = currentModeLabelNo(); const focused = document.activeElement; if(focused && focused.classList && focused.classList.contains('cell')){ const idx = Number(focused.dataset.index); stateNo.cells[idx] = val; updateCellClassNo(focused, val); stateNo.moves++; movesElNo.textContent = stateNo.moves; startTimerNo(); saveAutosNo(); } }
                                                function currentModeLabelNo(){ return currentModeNo===1? 'Fill' : currentModeNo===2? 'X mark' : 'Clear'; }

                                                function startTimerNo(){ if(stateNo.timerInt) return; stateNo.timerInt = setInterval(()=>{ stateNo.seconds++; timerElNo.textContent = stateNo.seconds + 's'; saveAutosNo(); },1000); }
                                                function stopTimerNo(){ if(stateNo.timerInt){ clearInterval(stateNo.timerInt); stateNo.timerInt = null; } }

                                                function checkSolutionNo(showFeedback=true){ const sol = puzzlesLocal[stateNo.puzzleId].solution; let correct = true; for(let r=0;r<stateNo.rows;r++){ for(let c=0;c<stateNo.cols;c++){ const idx = r*stateNo.cols + c; const expected = sol[r][c] === '1' ? 1 : 0; if(expected === 1 && stateNo.cells[idx] !== 1){ correct = false; } if(expected === 0 && stateNo.cells[idx] === 1){ correct = false; } } } if(showFeedback){ if(correct){ alert(`Correct! Puzzle solved in ${stateNo.moves} moves and ${stateNo.seconds} seconds.`); stopTimerNo(); } else { alert('Not correct yet. Keep going.'); } } return correct; }

                                                function solvePuzzleNo(){ const sol = puzzlesLocal[stateNo.puzzleId].solution; for(let r=0;r<stateNo.rows;r++){ for(let c=0;c<stateNo.cols;c++){ const idx = r*stateNo.cols + c; stateNo.cells[idx] = sol[r][c] === '1' ? 1 : 0; } } renderNo(); saveAutosNo(); stopTimerNo(); }

                                                const SAVE_KEY_NO = 'nonogramProgress_v1';
                                                function saveAutosNo(){ try{ const payload = { id: stateNo.puzzleId, rows: stateNo.rows, cols: stateNo.cols, cells: stateNo.cells, moves: stateNo.moves, seconds: stateNo.seconds }; localStorage.setItem(SAVE_KEY_NO, JSON.stringify(payload)); }catch(e){} }
                                                function manualSaveNo(){ try{ const key = SAVE_KEY_NO + '_manual'; const payload = { id: stateNo.puzzleId, rows: stateNo.rows, cols: stateNo.cols, cells: stateNo.cells, moves: stateNo.moves, seconds: stateNo.seconds, at:Date.now() }; localStorage.setItem(key, JSON.stringify(payload)); alert('Progress saved.'); }catch(e){ alert('Save failed'); } }
                                                function manualLoadNo(){ try{ const key = SAVE_KEY_NO + '_manual'; const raw = localStorage.getItem(key); if(!raw){ alert('No saved progress found'); return; } const p = JSON.parse(raw); if(p.id && puzzlesLocal[p.id] && Array.isArray(p.cells) && p.cells.length === p.rows * p.cols){ stateNo.puzzleId = p.id; stateNo.rows = p.rows; stateNo.cols = p.cols; stateNo.cells = p.cells.slice(); stateNo.moves = p.moves || 0; stateNo.seconds = p.seconds || 0; stopTimerNo(); renderNo(); alert('Loaded saved progress.'); } else alert('Saved data invalid.'); }catch(e){ alert('Load failed'); } }

                                                function tryAutoLoadNo(){ try{ const raw = localStorage.getItem(SAVE_KEY_NO); if(!raw) return false; const p = JSON.parse(raw); if(p.id && puzzlesLocal[p.id] && Array.isArray(p.cells) && p.cells.length === p.rows * p.cols){ stateNo.puzzleId = p.id; stateNo.rows = p.rows; stateNo.cols = p.cols; stateNo.cells = p.cells.slice(); stateNo.moves = p.moves || 0; stateNo.seconds = p.seconds || 0; renderNo(); startTimerNo(); return true; } }catch(e){} return false; }

                                                // named handlers for wiring
                                                function newBtnHandler(){ initPuzzleNo(puzzleSelectNo.value); }
                                                function checkBtnHandler(){ checkSolutionNo(true); }
                                                function solveBtnHandler(){ if(confirm('Reveal solution?')) solvePuzzleNo(); }
                                                function saveBtnHandler(){ manualSaveNo(); }
                                                function loadBtnHandler(){ manualLoadNo(); }

                                                // attach
                                                newBtnNo.addEventListener('click', newBtnHandler);
                                                checkBtnNo.addEventListener('click', checkBtnHandler);
                                                solveBtnNo.addEventListener('click', solveBtnHandler);
                                                saveBtnNo.addEventListener('click', saveBtnHandler);
                                                loadBtnNo.addEventListener('click', loadBtnHandler);
                                                puzzleSelectNo.addEventListener('change', ()=> initPuzzleNo(puzzleSelectNo.value));

                                                // init
                                                if(!tryAutoLoadNo()){ initPuzzleNo(puzzleSelectNo.value); } else { const computed = computeClues(puzzlesLocal[stateNo.puzzleId].solution); stateNo.rowClues = computed.rowClues; stateNo.colClues = computed.colClues; renderNo(); startTimerNo(); }

                                                // cleanup
                                                activeGameCleanup = function(){ try{ newBtnNo.removeEventListener('click', newBtnHandler); checkBtnNo.removeEventListener('click', checkBtnHandler); solveBtnNo.removeEventListener('click', solveBtnHandler); saveBtnNo.removeEventListener('click', saveBtnHandler); loadBtnNo.removeEventListener('click', loadBtnHandler); puzzleSelectNo.removeEventListener('change', ()=> initPuzzleNo(puzzleSelectNo.value)); // remove cell handlers inside grid
                                                        const cells = gridWrapNo.querySelectorAll('.cell'); cells.forEach(c => { c.removeEventListener('click', onCellClickNo); c.removeEventListener('contextmenu', onCellRightClickNo); }); stopTimerNo(); }catch(e){ console.error('nonogram cleanup', e); } activeGameCleanup = null; };
                                        }

                                                    function loadMorseTrainer(){
                                                            modalBody.innerHTML = `
                                                                    <style>
                                                                        :root{ --bg:#071425; --panel:#0f1724; --accent:#06b6d4; --ok:#16a34a; --muted:#9fb0c4; --text:#e6eef6 }
                                                                        .m-wrap{max-width:980px;margin:28px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0));}
                                                                        header{display:flex;justify-content:space-between;align-items:center;gap:12px}
                                                                        .controls select,input,button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px}
                                                                        button.primary{background:var(--accent);color:#022;border:none;font-weight:700}
                                                                        main{display:grid;grid-template-columns:1fr 320px;gap:18px;margin-top:14px}
                                                                        .panel{background:var(--panel);padding:12px;border-radius:10px}
                                                                        .center{display:flex;flex-direction:column;gap:12px;align-items:center}
                                                                        .display{font-size:36px;font-weight:800}
                                                                        .sub{font-size:14px;color:var(--muted)}
                                                                        .big-btn{padding:12px 18px;border-radius:10px;background:linear-gradient(180deg,#0b2430,#071829);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
                                                                        .input{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
                                                                        .kbd{display:flex;gap:8px;flex-wrap:wrap}
                                                                        .key{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);min-width:40px;text-align:center;cursor:pointer}
                                                                        .stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;text-align:center}
                                                                        .history{max-height:280px;overflow:auto}
                                                                        .dot{display:inline-block;width:12px;height:12px;border-radius:50%;background:var(--accent);margin:0 4px}
                                                                        .dash{display:inline-block;width:34px;height:12px;border-radius:6px;background:var(--accent);margin:0 4px}
                                                                    </style>
                                                                    <div class="m-wrap" role="application" aria-label="Morse code trainer">
                                                                        <header>
                                                                            <div>
                                                                                <h3>Morse Code Trainer</h3>
                                                                                <div class="sub">Learn Morse; listen, type, and test your recognition.</div>
                                                                            </div>
                                                                            <div class="controls">
                                                                                <label class="sub">Mode</label>
                                                                                <select id="morse-mode">
                                                                                    <option value="listen">Listen & Type</option>
                                                                                    <option value="type">Type & Hear</option>
                                                                                </select>
                                                                                <label class="sub">Speed (WPM)</label>
                                                                                <select id="morse-wpm"><option>8</option><option selected>12</option><option>18</option><option>24</option></select>
                                                                                <label class="sub">Volume</label>
                                                                                <input id="morse-volume" type="range" min="0" max="1" step="0.05" value="0.8" />
                                                                                <button id="morse-newBtn" class="primary">New</button>
                                                                            </div>
                                                                        </header>
                                                                        <main>
                                                                            <section class="panel center" aria-label="Trainer">
                                                                                <div style="width:100%;display:flex;justify-content:space-between;align-items:center">
                                                                                    <div class="stat">Score: <span id="morse-score">0</span></div>
                                                                                    <div class="stat">Streak: <span id="morse-streak">0</span></div>
                                                                                </div>
                                                                                <div class="display" id="morse-prompt">‚Äî</div>
                                                                                <div class="sub" id="morse-visual"></div>
                                                                                <div style="width:100%;display:flex;gap:8px">
                                                                                    <input id="morse-answer" class="input" placeholder="Type the letter or number and press Enter" aria-label="Answer input" />
                                                                                    <button id="morse-submit" class="big-btn">Submit</button>
                                                                                </div>
                                                                                <div style="display:flex;gap:8px;align-items:center;width:100%;justify-content:center">
                                                                                    <button id="morse-play" class="big-btn">Play Morse</button>
                                                                                    <button id="morse-hint" class="big-btn">Hint</button>
                                                                                    <button id="morse-skip" class="big-btn">Skip</button>
                                                                                </div>
                                                                                <div class="kbd" id="morse-charsRow" aria-hidden="false"></div>
                                                                            </section>
                                                                            <aside class="panel" aria-label="Settings & history">
                                                                                <div><strong>Settings</strong><div class="sub" style="margin-top:8px">Choose which characters to include</div><div style="margin-top:8px"><label><input type="checkbox" class="m-charToggle" data-group="letters" checked /> Letters A‚ÄìZ</label><br/><label><input type="checkbox" class="m-charToggle" data-group="digits" checked /> Digits 0‚Äì9</label></div></div>
                                                                                <div style="margin-top:12px"><strong>Recent attempts</strong><div id="morse-history" class="history sub" aria-live="polite" style="margin-top:8px">No attempts yet</div></div>
                                                                                <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap"><button id="morse-export" class="big-btn">Export</button><button id="morse-import" class="big-btn">Import</button><button id="morse-clear" class="big-btn">Clear</button></div>
                                                                            </aside>
                                                                        </main>
                                                                    </div>
                                                            `;

                                                            // Morse map
                                                            const MORSE = { 'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.','H':'....','I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.','O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-','V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..','0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.' };

                                                            // DOM
                                                            const modeSel = document.getElementById('morse-mode');
                                                            const wpmSel = document.getElementById('morse-wpm');
                                                            const volumeEl = document.getElementById('morse-volume');
                                                            const newBtn = document.getElementById('morse-newBtn');
                                                            const promptEl = document.getElementById('morse-prompt');
                                                            const morseVisual = document.getElementById('morse-visual');
                                                            const answerEl = document.getElementById('morse-answer');
                                                            const submitBtn = document.getElementById('morse-submit');
                                                            const playBtn = document.getElementById('morse-play');
                                                            const hintBtn = document.getElementById('morse-hint');
                                                            const skipBtn = document.getElementById('morse-skip');
                                                            const charsRow = document.getElementById('morse-charsRow');
                                                            const historyNode = document.getElementById('morse-history');
                                                            const scoreEl = document.getElementById('morse-score');
                                                            const streakEl = document.getElementById('morse-streak');
                                                            const exportBtn = document.getElementById('morse-export');
                                                            const importBtn = document.getElementById('morse-import');
                                                            const clearBtn = document.getElementById('morse-clear');

                                                            // state
                                                            let pool = []; let current = null; let score = 0, streak = 0; let recent = []; const STORAGE = 'morse_trainer_v1';
                                                            let audioCtx = null;

                                                            function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; }

                                                            function buildPool(){ pool = []; const includeLetters = document.querySelector('.m-charToggle[data-group="letters"]').checked; const includeDigits = document.querySelector('.m-charToggle[data-group="digits"]').checked; if(includeLetters) pool.push(...Object.keys(MORSE).filter(ch => /^[A-Z]$/.test(ch))); if(includeDigits) pool.push(...Object.keys(MORSE).filter(ch => /^[0-9]$/.test(ch))); if(pool.length === 0) pool.push(...Object.keys(MORSE).filter(ch => /^[A-Z]$/.test(ch))); }

                                                            function pickChar(){ if(pool.length === 0) buildPool(); const i = Math.floor(Math.random()*pool.length); current = pool[i]; promptEl.textContent = modeSel.value === 'type' ? current : '‚Äî'; renderMorseVisual(MORSE[current]); answerEl.value = ''; answerEl.focus(); }

                                                            function renderMorseVisual(code, flash=false){ morseVisual.innerHTML = ''; for(const s of code.split('')){ const el = document.createElement('span'); el.className = s === '.' ? 'dot' : 'dash'; morseVisual.appendChild(el); } if(flash){ morseVisual.classList.add('flash'); setTimeout(()=> morseVisual.classList.remove('flash'), 200); } }

                                                            function playMorse(character){ if(!character) return; const code = MORSE[character]; const wpm = parseInt(wpmSel.value,10) || 12; const dit = Math.max(30, Math.round(1200 / wpm)); const dah = dit * 3; const gap = dit; const vol = parseFloat(volumeEl.value) || 0.8; const ctx = ensureAudio(); let t = ctx.currentTime + 0.05; const oGain = ctx.createGain(); oGain.gain.value = vol; oGain.connect(ctx.destination); for(const s of code.split('')){ const osc = ctx.createOscillator(); osc.type = 'sine'; osc.frequency.value = 700; osc.connect(oGain); osc.start(t); const duration = s === '.' ? dit/1000 : dah/1000; osc.stop(t + duration); t += duration + gap/1000; } return Promise.resolve(); }

                                                            function submitAnswer(){ const val = (answerEl.value || '').trim().toUpperCase(); if(!current) return; const correct = val === current; recent.unshift({ at: Date.now(), target: current, answer: val, correct }); if(recent.length > 50) recent.length = 50; if(correct){ score++; streak++; scoreEl.textContent = score; streakEl.textContent = streak; flashResult(true); pickChar(); } else { streak = 0; streakEl.textContent = streak; flashResult(false); pickChar(); } renderHistory(); persist(); }

                                                            function flashResult(ok){ promptEl.style.transition = 'background 180ms'; promptEl.style.background = ok ? 'linear-gradient(90deg,#061b13,#0a3b2b)' : 'linear-gradient(90deg,#3b0710,#4a0b12)'; setTimeout(()=> promptEl.style.background = 'transparent', 200); }

                                                            function renderHistory(){ historyNode.innerHTML = ''; if(recent.length === 0){ historyNode.textContent = 'No attempts yet'; return; } for(const r of recent.slice(0,40)){ const d = document.createElement('div'); d.style.padding='6px 4px'; d.textContent = `${new Date(r.at).toLocaleTimeString()} ‚Ä¢ target: ${r.target} ‚Ä¢ answer: ${r.answer || '‚Äî'} ‚Ä¢ ${r.correct ? 'OK' : 'WRONG'}`; historyNode.appendChild(d); } }

                                                            function hint(){ if(!current) return; const code = MORSE[current]; const children = morseVisual.children; if(children.length > 0){ children[0].style.opacity = '1'; children[0].classList.add('flash'); setTimeout(()=> children[0].classList.remove('flash'), 500); } const old = promptEl.textContent; promptEl.textContent = current; setTimeout(()=> { promptEl.textContent = modeSel.value === 'type' ? current : '‚Äî'; }, 800); }

                                                            function persist(){ try{ const payload = { recent, score, streak }; localStorage.setItem(STORAGE, JSON.stringify(payload)); }catch(e){} }
                                                            function loadPersist(){ try{ const raw = localStorage.getItem(STORAGE); if(!raw) return; const obj = JSON.parse(raw); recent = obj.recent || []; score = obj.score || 0; streak = obj.streak || 0; scoreEl.textContent = score; streakEl.textContent = streak; }catch(e){} }

                                                            function buildCharRow(){ charsRow.innerHTML=''; for(const ch of Object.keys(MORSE)){ const btn = document.createElement('div'); btn.className='key'; btn.textContent = ch; btn.title = `Play ${ch}`; btn.addEventListener('click', ()=> { playMorse(ch); }); charsRow.appendChild(btn); } }

                                                            // named handlers
                                                            function submitHandler(){ submitAnswer(); }
                                                            function playHandler(){ if(!current) pickChar(); playMorse(current); renderMorseVisual(MORSE[current], true); }
                                                            function hintHandler(){ hint(); }
                                                            function skipHandler(){ pickChar(); }
                                                            function newHandler(){ score = 0; streak = 0; scoreEl.textContent = '0'; streakEl.textContent = '0'; recent = []; renderHistory(); persist(); pickChar(); }
                                                            function exportHandler(){ const data = JSON.stringify(recent, null, 2); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'morse_history.json'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 400); }
                                                            function importHandler(){ const input = document.createElement('input'); input.type='file'; input.accept='application/json'; input.onchange = async (e) => { const f = e.target.files[0]; if(!f) return; const text = await f.text(); try{ const arr = JSON.parse(text); if(Array.isArray(arr)){ recent = arr.concat(recent).slice(0,200); renderHistory(); persist(); alert('Imported'); } }catch(err){ alert('Invalid file'); } }; input.click(); }
                                                            function clearHandler(){ if(confirm('Clear attempts and score?')){ recent = []; score = 0; streak = 0; renderHistory(); scoreEl.textContent='0'; streakEl.textContent='0'; persist(); } }

                                                            // wire events
                                                            answerEl.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') submitAnswer(); });
                                                            submitBtn.addEventListener('click', submitHandler);
                                                            playBtn.addEventListener('click', playHandler);
                                                            hintBtn.addEventListener('click', hintHandler);
                                                            skipBtn.addEventListener('click', skipHandler);
                                                            newBtn.addEventListener('click', newHandler);
                                                            exportBtn.addEventListener('click', exportHandler);
                                                            importBtn.addEventListener('click', importHandler);
                                                            clearBtn.addEventListener('click', clearHandler);
                                                            document.querySelectorAll('.m-charToggle').forEach(cb => cb.addEventListener('change', ()=> { buildPool(); pickChar(); }));
                                                            function spaceHandler(e){ if(e.code === 'Space'){ e.preventDefault(); if(current){ playMorse(current); renderMorseVisual(MORSE[current], true); } } if(e.key.toLowerCase() === 's') { pickChar(); } if(e.key.toLowerCase() === 'h') { hint(); } }
                                                            document.addEventListener('keydown', spaceHandler);

                                                            // init
                                                            buildPool(); buildCharRow(); loadPersist(); renderHistory(); pickChar();

                                                            // cleanup
                                                            activeGameCleanup = function(){ try{ submitBtn.removeEventListener('click', submitHandler); playBtn.removeEventListener('click', playHandler); hintBtn.removeEventListener('click', hintHandler); skipBtn.removeEventListener('click', skipHandler); newBtn.removeEventListener('click', newHandler); exportBtn.removeEventListener('click', exportHandler); importBtn.removeEventListener('click', importHandler); clearBtn.removeEventListener('click', clearHandler); document.querySelectorAll('.m-charToggle').forEach(cb => cb.removeEventListener('change', ()=> { buildPool(); pickChar(); })); document.removeEventListener('keydown', spaceHandler); // remove char row handlers
                                                                    const keys = document.querySelectorAll('#morse-charsRow .key'); keys.forEach(k => k.removeEventListener('click', ()=>{})); if(audioCtx && audioCtx.state !== 'closed'){ try{ audioCtx.close(); }catch(e){} } }catch(e){ console.error('morse cleanup', e); } activeGameCleanup = null; };
                                                    }

                function loadColorFloodGame(){
            modalBody.innerHTML = `
                <style>
                  :root{ --bg:#071425; --panel:#0f1724; --accent:#06b6d4; --muted:#9fb0c4; --text:#e6eef6; --cell-gap:6px; --cell-size:36px; --font:Inter,system-ui,Segoe UI,Roboto,Arial; }
                  *{box-sizing:border-box}
                  .wrap{max-width:980px;margin:28px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));box-shadow:0 12px 40px rgba(0,0,0,0.6)}
                  .board{display:grid;gap:var(--cell-gap);background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:8px;border-radius:8px}
                  .cell{width:var(--cell-size);height:var(--cell-size);border-radius:6px;box-shadow:inset 0 -6px 8px rgba(0,0,0,0.25);transition:transform .12s, box-shadow .12s}
                  .cell.flood{outline:3px solid rgba(255,255,255,0.06); transform:scale(1.03)}
                  .palette{display:flex;gap:8px;flex-wrap:wrap}
                  .colorBtn{width:44px;height:44px;border-radius:8px;border:2px solid rgba(255,255,255,0.04);cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center}
                  .small{font-size:13px;color:var(--muted)}
                  .panel{background:var(--panel);padding:12px;border-radius:10px}
                  .controls select,button,input{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
                  @media (max-width:880px){ :root{--cell-size:30px} .wrap{padding:12px} .palette .colorBtn{width:36px;height:36px} }
                </style>
                <div class="wrap" role="application" aria-label="Color Flood game">
                                    <header>
                                        <div>
                                            <h1>Color Flood</h1>
                                            <div class="small">Flood the board from top-left by choosing colors. Try to fill the grid in few moves.</div>
                                        </div>
                                        <div class="controls">
                                            <label class="small">Size</label>
                                            <select id="cf-sizeSel"><option value="8">8√ó8</option><option value="12" selected>12√ó12</option><option value="16">16√ó16</option></select>
                                            <label class="small">Colors</label>
                                            <select id="cf-colorsSel"><option value="6" selected>6</option><option value="7">7</option><option value="8">8</option></select>
                                            <button id="cf-newBtn" class="primary">New Game</button>
                                        </div>
                                    </header>

                                    <main>
                                        <div class="panel left">
                                            <div class="stats" style="width:100%;justify-content:space-between">
                                                <div class="stat"><div class="small">Moves</div><div id="cf-moves" style="font-weight:800">0</div></div>
                                                <div class="stat"><div class="small">Best</div><div id="cf-best" style="font-weight:800">‚Äî</div></div>
                                                <div class="stat"><div class="small">Remaining</div><div id="cf-remaining" style="font-weight:800">‚Äî</div></div>
                                            </div>

                                            <div id="cf-board" class="board" aria-live="polite"></div>

                                            <div style="display:flex;gap:8px;margin-top:8px">
                                                <button id="cf-undoBtn" class="ghost">Undo</button>
                                                <button id="cf-hintBtn" class="ghost">Hint</button>
                                                <button id="cf-shuffleBtn" class="ghost">Shuffle</button>
                                            </div>
                                        </div>

                                        <aside class="panel" style="min-width:260px">
                                            <div style="display:flex;justify-content:space-between;align-items:center">
                                                <strong>Palette</strong>
                                                <div class="small">Click a color to flood</div>
                                            </div>

                                            <div id="cf-palette" class="palette" style="margin-top:12px"></div>

                                            <div style="margin-top:12px">
                                                <strong>Controls</strong>
                                                <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
                                                    <button id="cf-saveBtn" class="ghost">Save</button>
                                                    <button id="cf-loadBtn" class="ghost">Load</button>
                                                    <button id="cf-resetBest" class="ghost">Clear Best</button>
                                                </div>
                                            </div>

                                            <div style="margin-top:12px">
                                                <strong>How to play</strong>
                                                <div class="small" style="margin-top:6px">Select colors to flood the top-left region. The goal is to make the entire board one color in as few moves as possible.</div>
                                            </div>
                                        </aside>
                                    </main>

                                    <div class="footer">
                                        <div class="small">Keyboard: 1..N to pick color; U = Undo; H = Hint; N = New</div>
                                        <div class="small">Local best stored in your browser</div>
                                    </div>
                                </div>
                        `;

                        // Scoped DOM refs (prefixed with cf-)
                        const boardEl = document.getElementById('cf-board');
                        const paletteEl = document.getElementById('cf-palette');
                        const sizeSel = document.getElementById('cf-sizeSel');
                        const colorsSel = document.getElementById('cf-colorsSel');
                        const newBtn = document.getElementById('cf-newBtn');
                        const movesEl = document.getElementById('cf-moves');
                        const bestEl = document.getElementById('cf-best');
                        const remainingEl = document.getElementById('cf-remaining');
                        const undoBtn = document.getElementById('cf-undoBtn');
                        const hintBtn = document.getElementById('cf-hintBtn');
                        const shuffleBtn = document.getElementById('cf-shuffleBtn');
                        const saveBtn = document.getElementById('cf-saveBtn');
                        const loadBtn = document.getElementById('cf-loadBtn');
                        const resetBestBtn = document.getElementById('cf-resetBest');

                        const BEST_KEY = 'colorflood_best_v1';
                        const SAVE_KEY = 'colorflood_save_v1';

                        let cfg = { size: parseInt(sizeSel.value,10), colors: parseInt(colorsSel.value,10) };
                        let grid = [];
                        let moves = 0;
                        let best = null;
                        let history = [];
                        let palette = [];
                        let floodMask = null;

                        const COLOR_SETS = {
                            6: ['#e11d48','#f97316','#facc15','#10b981','#06b6d4','#60a5fa'],
                            7: ['#e11d48','#ec4899','#f97316','#facc15','#10b981','#06b6d4','#60a5fa'],
                            8: ['#ef4444','#ec4899','#f97316','#f59e0b','#10b981','#06b6d4','#3b82f6','#8b5cf6']
                        };

                        function idx(x,y){ return y*cfg.size + x; }
                        function xy(i){ return {x: i % cfg.size, y: Math.floor(i / cfg.size)}; }
                        function inBounds(x,y){ return x>=0 && y>=0 && x<cfg.size && y<cfg.size; }
                        function cloneGrid(g){ return g.slice(); }

                        function newGame(resetHistory=true){
                            cfg.size = parseInt(sizeSel.value,10);
                            cfg.colors = parseInt(colorsSel.value,10);
                            palette = COLOR_SETS[cfg.colors] ? COLOR_SETS[cfg.colors].slice(0,cfg.colors) : COLOR_SETS[6];
                            grid = new Array(cfg.size * cfg.size);
                            for(let i=0;i<grid.length;i++) grid[i] = Math.floor(Math.random() * cfg.colors);
                            moves = 0;
                            floodMask = null;
                            history = resetHistory ? [] : history;
                            updateBestFromStorage();
                            renderPalette();
                            computeFloodMask();
                            renderBoard();
                            updateStats();
                        }

                        function renderPalette(){
                            paletteEl.innerHTML = '';
                            palette.forEach((col, i) => {
                                const btn = document.createElement('button');
                                btn.className = 'colorBtn';
                                btn.title = `Color ${i+1}`;
                                btn.style.background = col;
                                btn.dataset.index = i;
                                btn.addEventListener('click', ()=> selectColor(i));
                                paletteEl.appendChild(btn);
                            });
                        }

                        function renderBoard(){
                            boardEl.innerHTML = '';
                            boardEl.style.gridTemplateColumns = `repeat(${cfg.size}, var(--cell-size, 36px))`;
                            for(let y=0;y<cfg.size;y++){
                                for(let x=0;x<cfg.size;x++){
                                    const i = idx(x,y);
                                    const cell = document.createElement('div');
                                    cell.className = 'cell';
                                    cell.style.background = palette[grid[i]];
                                    if(floodMask && floodMask[i]) cell.classList.add('flood');
                                    boardEl.appendChild(cell);
                                }
                            }
                            updateRemaining();
                        }

                        function updateRemaining(){ const total = grid.length; const flooded = floodMask ? floodMask.filter(Boolean).length : 0; remainingEl.textContent = `${total - flooded}`; }

                        function computeFloodMask(g = grid){ const n = g.length; const mask = new Array(n).fill(false); const startColor = g[0]; const stack = [0]; mask[0]=true; while(stack.length){ const i = stack.pop(); const {x,y} = xy(i); const neighbors = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]; for(const [nx,ny] of neighbors){ if(!inBounds(nx,ny)) continue; const ni = idx(nx,ny); if(!mask[ni] && g[ni] === startColor){ mask[ni] = true; stack.push(ni); } } } floodMask = mask; return mask; }

                        function floodWithColor(colorIndex){ if(floodMask === null) computeFloodMask(); const startColor = grid[0]; if(colorIndex === startColor) return; history.push({grid: cloneGrid(grid), moves}); for(let i=0;i<grid.length;i++){ if(floodMask[i]) grid[i] = colorIndex; } computeFloodMask(); moves++; renderBoard(); updateStats(); checkWin(); }

                        function checkWin(){ const allSame = grid.every(c => c === grid[0]); if(allSame){ const storedBest = loadBestFromStorage(); if(storedBest === null || moves < storedBest){ saveBestToStorage(moves); best = moves; } setTimeout(()=> alert(`You won in ${moves} moves!`), 80); } }

                        function undo(){ if(history.length === 0) return; const last = history.pop(); grid = cloneGrid(last.grid); moves = last.moves; computeFloodMask(); renderBoard(); updateStats(); }

                        function hint(){ if(floodMask === null) computeFloodMask(); const startColor = grid[0]; const scores = new Array(cfg.colors).fill(0); for(let c=0;c<cfg.colors;c++){ if(c === startColor) continue; const g = grid.slice(); for(let i=0;i<g.length;i++) if(floodMask[i]) g[i] = c; const newMask = new Array(g.length).fill(false); const stack=[0]; newMask[0]=true; while(stack.length){ const i = stack.pop(); const {x,y} = xy(i); const neighbors = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]]; for(const [nx,ny] of neighbors){ if(!inBounds(nx,ny)) continue; const ni = idx(nx,ny); if(!newMask[ni] && g[ni] === g[0]){ newMask[ni]=true; stack.push(ni); } } } scores[c] = newMask.filter(Boolean).length; } let bestC = null, bestScore = -1; for(let c=0;c<scores.length;c++){ if(scores[c] > bestScore){ bestScore = scores[c]; bestC = c; } } if(bestC !== null){ alert(`Hint: choose color ${bestC+1} (it would flood ${bestScore} cells).`); } }

                        function shuffle(){ const indices = []; for(let i=0;i<grid.length;i++) if(!floodMask[i]) indices.push(i); for(let i=indices.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); const a = indices[i], b = indices[j]; const tmp = grid[a]; grid[a] = grid[b]; grid[b] = tmp; } computeFloodMask(); renderBoard(); updateStats(); }

                        function loadBestFromStorage(){ try{ const raw = localStorage.getItem(BEST_KEY); if(!raw) return null; return parseInt(raw,10); }catch(e){ return null; } }
                        function saveBestToStorage(val){ try{ localStorage.setItem(BEST_KEY, String(val)); }catch(e){} best = val; bestEl.textContent = best; }
                        function updateBestFromStorage(){ best = loadBestFromStorage(); bestEl.textContent = best === null ? '‚Äî' : best; }

                        function saveGame(){ const payload = { cfg, grid, moves, history, palette }; try{ localStorage.setItem(SAVE_KEY, JSON.stringify(payload)); alert('Game saved'); }catch(e){ alert('Save failed'); } }
                        function loadGame(){ try{ const raw = localStorage.getItem(SAVE_KEY); if(!raw){ alert('No save'); return; } const obj = JSON.parse(raw); if(obj.cfg) cfg = obj.cfg; if(obj.grid) grid = obj.grid; if(typeof obj.moves === 'number') moves = obj.moves; if(Array.isArray(obj.history)) history = obj.history; if(Array.isArray(obj.palette)) palette = obj.palette; sizeSel.value = cfg.size; colorsSel.value = cfg.colors; computeFloodMask(); renderPalette(); renderBoard(); updateStats(); alert('Save loaded'); }catch(e){ alert('Load failed'); } }

                        function resetBest(){ if(confirm('Clear best score?')){ localStorage.removeItem(BEST_KEY); updateBestFromStorage(); } }

                        function updateStats(){ movesEl.textContent = moves; updateRemaining(); bestEl.textContent = best === null ? '‚Äî' : best; }

                        function selectColor(ci){ floodWithColor(ci); }

                        function cfKeydownHandler(e){ if(e.key >= '1' && e.key <= String(cfg.colors)) { selectColor(parseInt(e.key,10)-1); } else if(e.key.toLowerCase() === 'u') undo(); else if(e.key.toLowerCase() === 'h') hint(); else if(e.key.toLowerCase() === 'n') newGame(); }

                        // UI wiring (named handlers)
                        newBtn.addEventListener('click', newGame);
                        sizeSel.addEventListener('change', newGame);
                        colorsSel.addEventListener('change', newGame);
                        undoBtn.addEventListener('click', undo);
                        hintBtn.addEventListener('click', hint);
                        shuffleBtn.addEventListener('click', shuffle);
                        saveBtn.addEventListener('click', saveGame);
                        loadBtn.addEventListener('click', loadGame);
                        resetBestBtn.addEventListener('click', resetBest);
                        document.addEventListener('keydown', cfKeydownHandler);

                        // initial load
                        newGame();

                        // expose limited debug
                        window._colorflood = { cfg, grid, newGame, undo, hint, saveGame, loadGame, shuffle };

                        // cleanup
                        activeGameCleanup = function(){ try{ newBtn.removeEventListener('click', newGame); sizeSel.removeEventListener('change', newGame); colorsSel.removeEventListener('change', newGame); undoBtn.removeEventListener('click', undo); hintBtn.removeEventListener('click', hint); shuffleBtn.removeEventListener('click', shuffle); saveBtn.removeEventListener('click', saveGame); loadBtn.removeEventListener('click', loadGame); resetBestBtn.removeEventListener('click', resetBest); document.removeEventListener('keydown', cfKeydownHandler); // clear DOM
                                        boardEl.innerHTML = ''; paletteEl.innerHTML = ''; }catch(e){ console.error('colorflood cleanup', e); } activeGameCleanup = null; };
                }

        gameCards.forEach(card => {
            card.addEventListener('click', () => {
                const gameId = card.getAttribute('data-game');
                const gameName = card.querySelector('span').textContent;
                modalBody.innerHTML = '';
                if (snakeGameLoop) {
                    clearTimeout(snakeGameLoop);
                }
                if (pongGameLoop) {
                    cancelAnimationFrame(pongGameLoop);
                }
                if (gameId === 'snake') {
                    loadSnakeGame();
                } else if (gameId === 'pong') {
                    loadPongGame();
                } else if (gameId === 'minesweeper') {
                    loadMinesweeperGame();
                } else if (gameId === 'sudoku') {
                    loadSudokuGame();
                } else if (gameId === '2048') {
                    load2048Game();
                } else if (gameId === 'space-invaders') {
                    loadSpaceInvadersGame();
                } else if (gameId === 'flappy-bird') {
                    loadFlappyBirdGame();
                } else if (gameId === 'tetris') {
                    loadTetrisGame();
                } else if (gameId === 'simon-says') {
                    loadSimonGame();
                } else if (gameId === '15-puzzle') {
                    loadFifteenGame();
                } else if (gameId === 'lights-out') {
                    loadLightsOutGame();
                } else if (gameId === 'nonogram') {
                    loadNonogramGame();
                } else if (gameId === 'morse-code-trainer') {
                    loadMorseTrainer();
                } else if (gameId === 'color-flood') {
                    loadColorFloodGame();
                } else if (gameId === 'rock-paper-scissors') {
                    loadRockPaperScissorsGame();
                } else if (gameId === 'whack-a-mole') {
                    loadWhackAMoleGame();
                } else {
                    modalBody.innerHTML = `
                        <h3 id="gameTitle">${gameName}</h3>
                        <p>Coming Soon</p>
                    `;
                }
                modal.style.display = 'flex';
            });
        });

                // Rock Paper Scissors loader
                function loadRockPaperScissorsGame(){
                        modalBody.innerHTML = `
                                <style>
                                    /* Scoped RPS styles */
                                    #rps-wrap{color:#e6eef6;font-family:system-ui,Arial,sans-serif}
                                    #rps-wrap .small{font-size:13px;color:#9fb0c4}
                                    #rps-choices{display:flex;gap:12px;justify-content:center;margin:12px 0}
                                    .rps-choice{width:110px;height:110px;border-radius:12px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:36px;font-weight:800;cursor:pointer;user-select:none}
                                    .rps-choice .label{font-size:13px;margin-top:6px;color:#9fb0c4}
                                    #rps-cpuBox{width:180px;height:180px;border-radius:12px;background:linear-gradient(180deg,#0b1b2a,#071018);display:flex;align-items:center;justify-content:center;font-size:44px;font-weight:900;margin:0 auto}
                                    .rps-result{font-size:18px;font-weight:800;text-align:center}
                                    .rps-scoreboard{display:flex;gap:10px;justify-content:center;margin:10px 0}
                                </style>
                                <div id="rps-wrap">
                                    <h3 id="gameTitle">Rock Paper Scissors</h3>
                                    <div id="rps-cpuBox">?</div>
                                    <div id="rps-choices" role="radiogroup" aria-label="Choices">
                                        <div class="rps-choice" data-move="rock" id="rps-rockBtn">‚úä<div class="label">Rock</div></div>
                                        <div class="rps-choice" data-move="paper" id="rps-paperBtn">‚úã<div class="label">Paper</div></div>
                                        <div class="rps-choice" data-move="scissors" id="rps-scissorsBtn">‚úåÔ∏è<div class="label">Scissors</div></div>
                                    </div>
                                    <div class="rps-result" id="rps-roundResult">Make your move</div>
                                    <div class="rps-scoreboard">
                                        <div class="stat">You: <span id="rps-playerScore">0</span></div>
                                        <div class="stat">CPU: <span id="rps-cpuScore">0</span></div>
                                        <div class="stat">Rounds: <span id="rps-roundsPlayed">0</span>/<span id="rps-roundsTotal">3</span></div>
                                        <div class="small">High Wins: <span id="rps-highWins">0</span></div>
                                    </div>
                                    <div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
                                        <button id="rps-autoBtn" class="ghost">Auto Play</button>
                                        <button id="rps-playAgain" class="primary">Play Round</button>
                                        <button id="rps-resetBtn" class="ghost">Reset Scores</button>
                                    </div>
                                    <div style="margin-top:12px;text-align:center"><small class="small">Keyboard: R = Rock, P = Paper, S = Scissors. Best of N.</small></div>
                                    <div id="rps-history" class="small" style="margin-top:12px;max-height:180px;overflow:auto"></div>
                                </div>
                        `;

                        // Scoped elements
                        const rockBtn = modalBody.querySelector('#rps-rockBtn');
                        const paperBtn = modalBody.querySelector('#rps-paperBtn');
                        const scissorsBtn = modalBody.querySelector('#rps-scissorsBtn');
                        const cpuBox = modalBody.querySelector('#rps-cpuBox');
                        const resultEl = modalBody.querySelector('#rps-roundResult');
                        const playerScoreEl = modalBody.querySelector('#rps-playerScore');
                        const cpuScoreEl = modalBody.querySelector('#rps-cpuScore');
                        const roundsPlayedEl = modalBody.querySelector('#rps-roundsPlayed');
                        const roundsTotalEl = modalBody.querySelector('#rps-roundsTotal');
                        const bestOfSel = modalBody.querySelector('#bestOf') || document.getElementById('bestOf');
                        const difficultySel = modalBody.querySelector('#difficulty') || document.getElementById('difficulty');
                        const resetBtn = modalBody.querySelector('#rps-resetBtn');
                        const playAgainBtn = modalBody.querySelector('#rps-playAgain');
                        const autoBtn = modalBody.querySelector('#rps-autoBtn');
                        const historyEl = modalBody.querySelector('#rps-history');
                        const highWinsEl = modalBody.querySelector('#rps-highWins');

                        const MOVES = ['rock','paper','scissors'];
                        const BEATS = { rock: 'scissors', paper: 'rock', scissors: 'paper' };

                        const STORE_KEY = 'rps_game_v1';
                        let animInterval = null;

                        // Determine initial rounds total safely ‚Äî bestOfSel may not exist on the main page
                        const defaultRounds = 3;
                        const initialRounds = (bestOfSel && bestOfSel.value) ? parseInt(bestOfSel.value, 10) : defaultRounds;
                        let state = { playerScore:0, cpuScore:0, roundsPlayed:0, roundsTotal: initialRounds, history:[], highWins:0, auto:false };

                        function loadState(){ try{ const raw = localStorage.getItem(STORE_KEY); if(raw){ const obj=JSON.parse(raw); state.history = obj.history||[]; state.highWins = obj.highWins||0; } }catch(e){} highWinsEl.textContent = state.highWins; renderHistory(); }
                        function saveState(){ try{ localStorage.setItem(STORE_KEY, JSON.stringify({ history: state.history, highWins: state.highWins })); }catch(e){} }

                        function setRoundsTotal(){ if(bestOfSel && bestOfSel.value){ state.roundsTotal = parseInt(bestOfSel.value,10); roundsTotalEl.textContent = state.roundsTotal; } else { state.roundsTotal = defaultRounds; roundsTotalEl.textContent = state.roundsTotal; } }
                        setRoundsTotal();
                        const onBestOfChange = ()=>{ setRoundsTotal(); resetRound(); };
                        // bestOf is global on page; attach change if available
                        if(bestOfSel) bestOfSel.addEventListener('change', onBestOfChange);

                        function pickCpuMove(playerMove){ const diff = difficultySel ? difficultySel.value : 'normal'; if(diff === 'easy'){ const r=Math.random(); if(r<0.25) return BEATS[playerMove]; if(r<0.5) return playerMove; return MOVES[Math.floor(Math.random()*3)]; } else if(diff==='hard'){ if(Math.random()<0.4){ for(const m of MOVES) if(BEATS[m]===playerMove) return m; } return MOVES[Math.floor(Math.random()*3)]; } else return MOVES[Math.floor(Math.random()*3)]; }

                        function animateCpuReveal(finalMove, cb){ let ticks=6; cpuBox.textContent=''; clearInterval(animInterval); animInterval = setInterval(()=>{ cpuBox.textContent = MOVES[Math.floor(Math.random()*3)].slice(0,1).toUpperCase(); if(--ticks<=0){ clearInterval(animInterval); animInterval = null; cpuBox.textContent = emojiFor(finalMove); if(cb) cb(); } }, 110); }

                        function emojiFor(move){ if(move==='rock') return '‚úä'; if(move==='paper') return '‚úã'; if(move==='scissors') return '‚úåÔ∏è'; return '?'; }

                        function playRound(playerMove){ if(!playerMove) return; highlightChoice(playerMove); const cpuMove = pickCpuMove(playerMove); animateCpuReveal(cpuMove, ()=>{ decideRound(playerMove, cpuMove); if(state.auto && !isGameOver()){ setTimeout(()=>{ const randomMove = MOVES[Math.floor(Math.random()*3)]; playRound(randomMove); }, 700); } }); }

                        function decideRound(playerMove, cpuMove){ state.roundsPlayed++; roundsPlayedEl.textContent = state.roundsPlayed; if(playerMove===cpuMove){ resultEl.textContent = `Tie ‚Äî both chose ${playerMove}`; resultEl.className='rps-result'; state.history.unshift({playerMove,cpuMove,result:'tie', at:Date.now()}); } else if(BEATS[playerMove]===cpuMove){ state.playerScore++; playerScoreEl.textContent = state.playerScore; resultEl.textContent = `You win ‚Äî ${playerMove} beats ${cpuMove}`; resultEl.className='rps-result flash-win'; state.history.unshift({playerMove,cpuMove,result:'win', at:Date.now()}); } else { state.cpuScore++; cpuScoreEl.textContent = state.cpuScore; resultEl.textContent = `You lose ‚Äî ${cpuMove} beats ${playerMove}`; resultEl.className='rps-result flash-lose'; state.history.unshift({playerMove,cpuMove,result:'lose', at:Date.now()}); } if(state.history.length>100) state.history.length=100; renderHistory(); checkForMatchEnd(); }

                        function highlightChoice(move){ modalBody.querySelectorAll('.rps-choice').forEach(c=>c.classList.remove('active')); const el = modalBody.querySelector(`.rps-choice[data-move="${move}"]`); if(el) el.classList.add('active'); setTimeout(()=>{ if(el) el.classList.remove('active'); },300); }

                        function isGameOver(){ const needed = Math.ceil(state.roundsTotal/2); if(state.playerScore>=needed || state.cpuScore>=needed) return true; if(state.roundsPlayed>=state.roundsTotal) return true; return false; }

                        function checkForMatchEnd(){ if(isGameOver()){ let msg=''; if(state.playerScore>state.cpuScore){ msg = `Match over ‚Äî You win ${state.playerScore} : ${state.cpuScore}`; if(state.playerScore>state.highWins){ state.highWins = state.playerScore; highWinsEl.textContent = state.highWins; } } else if(state.playerScore<state.cpuScore){ msg = `Match over ‚Äî CPU wins ${state.cpuScore} : ${state.playerScore}`; } else { msg = `Match over ‚Äî Draw ${state.playerScore} : ${state.cpuScore}`; } resultEl.textContent = msg; state.history.unshift({matchResult: msg, at: Date.now(), final: {player: state.playerScore, cpu: state.cpuScore}}); if(state.history.length>200) state.history.length=200; saveState(); renderHistory(); state.auto = false; autoBtn.textContent = 'Auto Play'; } }

                        function renderHistory(){ historyEl.innerHTML=''; const h = state.history.slice(0,40); if(h.length===0){ historyEl.textContent = 'No rounds yet'; return; } h.forEach(entry=>{ const d = document.createElement('div'); d.style.padding='6px 4px'; if(entry.result){ d.textContent = `${new Date(entry.at).toLocaleTimeString()} ‚Äî You: ${entry.playerMove} | CPU: ${entry.cpuMove} ‚Üí ${entry.result.toUpperCase()}`; } else if(entry.matchResult){ d.textContent = `${new Date(entry.at).toLocaleTimeString()} ‚Äî ${entry.matchResult}`; } historyEl.appendChild(d); }); }

                        function resetRound(){ state.playerScore=0; state.cpuScore=0; state.roundsPlayed=0; playerScoreEl.textContent='0'; cpuScoreEl.textContent='0'; roundsPlayedEl.textContent='0'; roundsTotalEl.textContent=state.roundsTotal; cpuBox.textContent='?'; resultEl.textContent='Make your move'; resultEl.className='rps-result'; saveState(); }

                        // Named handlers so cleanup can remove them
                        const onRock = ()=>playRound('rock');
                        const onPaper = ()=>playRound('paper');
                        const onScissors = ()=>playRound('scissors');
                        const onPlayAgain = ()=>{ cpuBox.textContent='?'; resultEl.textContent='Make your move'; resultEl.className='rps-result'; if(state.auto){ const randomMove = MOVES[Math.floor(Math.random()*3)]; playRound(randomMove); } };
                        const onAuto = ()=>{ state.auto = !state.auto; autoBtn.textContent = state.auto ? 'Stop Auto' : 'Auto Play'; if(state.auto){ const randomMove = MOVES[Math.floor(Math.random()*3)]; playRound(randomMove); } };
                        const onReset = ()=>{ if(confirm('Reset saved history and high wins?')){ state.history=[]; state.highWins=0; saveState(); renderHistory(); highWinsEl.textContent=0; } };
                        const onKeydown = (e)=>{ const k = e.key.toLowerCase(); if(k==='r') playRound('rock'); if(k==='p') playRound('paper'); if(k==='s') playRound('scissors'); if(e.key===' '){ e.preventDefault(); onPlayAgain(); } };

                        rockBtn.addEventListener('click', onRock);
                        paperBtn.addEventListener('click', onPaper);
                        scissorsBtn.addEventListener('click', onScissors);
                        playAgainBtn.addEventListener('click', onPlayAgain);
                        autoBtn.addEventListener('click', onAuto);
                        resetBtn.addEventListener('click', onReset);
                        document.addEventListener('keydown', onKeydown);

                        // init
                        loadState(); resetRound();

                        // cleanup
                        activeGameCleanup = function(){ try{ rockBtn.removeEventListener('click', onRock); paperBtn.removeEventListener('click', onPaper); scissorsBtn.removeEventListener('click', onScissors); playAgainBtn.removeEventListener('click', onPlayAgain); autoBtn.removeEventListener('click', onAuto); resetBtn.removeEventListener('click', onReset); if(bestOfSel) bestOfSel.removeEventListener('change', onBestOfChange); document.removeEventListener('keydown', onKeydown); if(animInterval) { clearInterval(animInterval); animInterval = null; } }catch(e){ console.error('rps cleanup', e); } activeGameCleanup = null; };
                }

        // Whack-a-Mole loader (namespaced wam-)
        function loadWhackAMoleGame(){
            modalBody.innerHTML = `
                <style>
                  /* Scoped Whack-a-Mole styles (wam-) */
                  #wam-wrap{color:#e6eef6;font-family:system-ui,Arial,sans-serif}
                  .wam-wrap .small{font-size:13px;color:#9fb0c4}
                  .wam-panel{padding:12px}
                  .wam-board{display:grid;gap:14px;width:100%;max-width:680px;margin:0 auto}
                  .wam-hole{width:100%;aspect-ratio:1/1;border-radius:14px;background:radial-gradient(circle at 30% 20%, #0b1b2a,#071018 50%);display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;cursor:pointer;user-select:none}
                  .wam-mole{position:absolute;bottom:-60%;width:70%;max-width:160px;transform:translateY(100%);transition:transform .18s ease;pointer-events:none}
                  .wam-mole.show{transform:translateY(0%);pointer-events:auto}
                  .wam-pop{position:absolute;left:50%;top:18%;transform:translateX(-50%);font-size:20px;font-weight:900;padding:6px 8px;border-radius:8px;opacity:0;transition:all .35s ease}
                  .wam-pop.hit{background:linear-gradient(90deg,#a7f3d0,#86efac);color:#043025;opacity:1;transform:translate(-50%,-20%) scale(1)}
                  .wam-pop.miss{background:linear-gradient(90deg,#fecaca,#fca5a5);color:#450202;opacity:1;transform:translate(-50%,-20%) scale(1)}
                  .wam-controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:12px}
                </style>
                <div id="wam-wrap">
                    <h3 id="gameTitle">Whack-a-Mole</h3>
                    <div style="display:flex;gap:12px;justify-content:center;align-items:center;flex-wrap:wrap">
                        <select id="wam-gridSize">
                            <option value="3">3 √ó 3</option>
                            <option value="4" selected>4 √ó 4</option>
                            <option value="5">5 √ó 5</option>
                        </select>
                        <select id="wam-difficulty">
                            <option value="easy">Easy</option>
                            <option value="normal" selected>Normal</option>
                            <option value="hard">Hard</option>
                        </select>
                        <button id="wam-startBtn" class="primary">Start</button>
                        <button id="wam-pauseBtn" class="ghost">Pause</button>
                        <button id="wam-resetBtn" class="ghost">Reset</button>
                    </div>

                    <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
                        <div style="display:flex;gap:8px;align-items:center">
                            <div class="stat"><div class="label">Score</div><div class="value" id="wam-score">0</div></div>
                            <div class="stat"><div class="label">Time</div><div class="value" id="wam-timeLeft">60</div></div>
                            <div class="stat"><div class="label">Misses</div><div class="value" id="wam-misses">0</div></div>
                        </div>
                        <div style="display:flex;gap:8px;align-items:center">
                            <div class="small">High Score: <strong id="wam-highScore">0</strong></div>
                        </div>
                    </div>

                    <div id="wam-boardContainer" style="width:100%;display:flex;justify-content:center;align-items:center;margin-top:12px">
                        <div id="wam-board" class="wam-board"></div>
                    </div>

                    <div class="wam-controls">
                        <button id="wam-addMoleBtn" class="ghost">+ Mole (test)</button>
                        <div class="small">Tip: Press Space to whack center (keyboard)</div>
                    </div>

                    <div style="margin-top:12px">
                        <strong>Game Log</strong>
                        <div id="wam-log" class="small" style="max-height:160px;overflow:auto;margin-top:6px"></div>
                    </div>
                </div>
            `;

            // Scoped elements
            const board = modalBody.querySelector('#wam-board');
            const gridSizeSel = modalBody.querySelector('#wam-gridSize');
            const difficultySel = modalBody.querySelector('#wam-difficulty');
            const startBtn = modalBody.querySelector('#wam-startBtn');
            const pauseBtn = modalBody.querySelector('#wam-pauseBtn');
            const resetBtn = modalBody.querySelector('#wam-resetBtn');
            const addMoleBtn = modalBody.querySelector('#wam-addMoleBtn');
            const scoreEl = modalBody.querySelector('#wam-score');
            const timeLeftEl = modalBody.querySelector('#wam-timeLeft');
            const missesEl = modalBody.querySelector('#wam-misses');
            const logEl = modalBody.querySelector('#wam-log');
            const highScoreEl = modalBody.querySelector('#wam-highScore');

            const SAVE_KEY = 'whackamole_save_v1';

            let config = { cols: parseInt(gridSizeSel.value,10), difficulty: difficultySel.value, duration: 60 };

            let state = { running: false, paused: false, score: 0, timeLeft: config.duration, misses: 0, totalWhacks: 0, totalMisses: 0, molesWhacked: 0, activeMoles: {}, highScore: 0 };

            const DIFF = {
              easy:   { popInterval: [900,1400], moleDuration: [1200,1300], simultaneous:1 },
              normal: { popInterval: [700,1100], moleDuration: [900,1100], simultaneous:1 },
              hard:   { popInterval: [450,800],  moleDuration: [700,900],  simultaneous:2 }
            };

            const MOLE_SVG = encodeURIComponent(`
              <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'>
                <g>
                  <ellipse cx='60' cy='96' rx='44' ry='18' fill='#2b2620' opacity='0.35'/>
                  <circle cx='60' cy='60' r='34' fill='#533a2a'/>
                  <ellipse cx='42' cy='55' rx='8' ry='6' fill='#2b2620'/>
                  <ellipse cx='78' cy='55' rx='8' ry='6' fill='#2b2620'/>
                  <circle cx='48' cy='52' r='4' fill='#fff'/>
                  <circle cx='72' cy='52' r='4' fill='#fff'/>
                  <circle cx='48' cy='52' r='2' fill='#000'/>
                  <circle cx='72' cy='52' r='2' fill='#000'/>
                  <path d='M50 72 q10 8 20 0' stroke='#000' stroke-width='3' fill='none' stroke-linecap='round'/>
                </g>
              </svg>`);

            // Utilities
            function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
            function now(){ return Date.now(); }
            function wmLog(msg){ const el = document.createElement('div'); el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`; logEl.prepend(el); }
            function playBeep(freq=440, time=0.06, vol=0.12){ try{ const ctx = new (window.AudioContext || window.webkitAudioContext)(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.type = 'sine'; o.frequency.value = freq; g.gain.value = vol; o.connect(g); g.connect(ctx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + time); setTimeout(()=>{ o.stop(); ctx.close(); }, time*1000 + 50); }catch(e){} }

            // Board
            let holes = [];
            function buildBoard(){ board.innerHTML = ''; holes = []; const cols = config.cols; board.style.gridTemplateColumns = `repeat(${cols}, 1fr)`; board.style.width = '100%'; board.style.maxWidth = `${Math.min(720, cols * 120)}px`; for(let i=0;i<cols*cols;i++){ const hole = document.createElement('div'); hole.className = 'wam-hole'; hole.dataset.index = i; const mole = document.createElement('div'); mole.className = 'wam-mole'; mole.innerHTML = `<img src="data:image/svg+xml;utf8,${MOLE_SVG}" alt="mole">`; hole.appendChild(mole); const pop = document.createElement('div'); pop.className = 'wam-pop'; hole.appendChild(pop); hole.addEventListener('pointerdown', onHolePointerDown); holes.push({hole,mole,pop}); board.appendChild(hole); } }

            // Scheduler and mole logic
            let scheduler = null; let countdownTimer = null;
            function startScheduler(){ stopScheduler(); scheduler = setInterval(scheduleTick, 150); }
            function stopScheduler(){ if(scheduler){ clearInterval(scheduler); scheduler = null; } }
            function scheduleTick(){ if(!state.running || state.paused) return; const diff = DIFF[config.difficulty]; const activeCount = Object.keys(state.activeMoles).length; const allowed = diff.simultaneous - activeCount; for(let i=0;i<allowed;i++){ if(Math.random() < 0.35) spawnMole(); } if(Math.random() < 0.22) spawnMole(); }
            function spawnMole(){ const diff = DIFF[config.difficulty]; const emptyIndices = holes.map((_,i)=>i).filter(i=>!(i in state.activeMoles)); if(emptyIndices.length === 0) return; const idx = emptyIndices[rand(0, emptyIndices.length-1)]; const duration = rand(diff.moleDuration[0], diff.moleDuration[1]); showMoleAt(idx, duration); }

            function showMoleAt(index, duration){ const target = holes[index]; if(!target) return; const moleEl = target.mole; const popEl = target.pop; const id = index; state.activeMoles[id] = { index, shownAt: now(), duration, hit: false, timeout: null }; moleEl.classList.add('show'); playBeep(720, 0.06, 0.08); const t = setTimeout(()=>{ if(state.activeMoles[id] && !state.activeMoles[id].hit){ state.misses++; state.totalMisses++; missesEl.textContent = state.misses; // show miss
                popEl.textContent = '-1'; popEl.classList.add('miss'); setTimeout(()=> popEl.classList.remove('miss'), 400); playBeep(160, 0.08, 0.06); } cleanupMole(id); }, duration); state.activeMoles[id].timeout = t; }

            function cleanupMole(id){ const slot = state.activeMoles[id]; if(!slot) return; const target = holes[id]; if(target){ target.mole.classList.remove('show'); target.pop.textContent = ''; } clearTimeout(slot.timeout); delete state.activeMoles[id]; }

            // Interaction
            function onHolePointerDown(e){ const idx = parseInt(this.dataset.index,10); if(state.activeMoles[idx]){ const moleObj = state.activeMoles[idx]; if(moleObj.hit) return; moleObj.hit = true; state.totalWhacks++; state.score += 1; state.molesWhacked++; scoreEl.textContent = state.score; // feedback
                const popEl = holes[idx].pop; popEl.textContent = '+1'; popEl.classList.add('hit'); playBeep(980, 0.06, 0.12); clearTimeout(moleObj.timeout); setTimeout(()=> cleanupMole(idx), 260); if(state.score > state.highScore){ state.highScore = state.score; highScoreEl.textContent = state.highScore; saveToStorage(); } wmLog(`Whacked mole at ${idx}`); } else { state.totalWhacks++; state.misses++; state.totalMisses++; missesEl.textContent = state.misses; const popEl = holes[idx].pop; popEl.textContent = '-1'; popEl.classList.add('miss'); setTimeout(()=> popEl.classList.remove('miss'), 450); playBeep(160, 0.06, 0.06); wmLog(`Miss at ${idx}`); } }

            // keyboard whack center
            const onKeyDown = (e)=>{ if(e.code === 'Space'){ e.preventDefault(); const center = Math.floor((config.cols*config.cols)/2); const idx = Math.min(center, holes.length-1); if(holes[idx]) holes[idx].dispatchEvent(new PointerEvent('pointerdown', {bubbles:true})); } };

            function startGame(){ if(state.running) return; state.running = true; state.paused = false; config.cols = parseInt(gridSizeSel.value,10); config.difficulty = difficultySel.value; config.duration = 60; state.timeLeft = config.duration; state.score = 0; state.misses = 0; state.activeMoles = {}; buildBoard(); scoreEl.textContent = state.score; timeLeftEl.textContent = state.timeLeft; missesEl.textContent = state.misses; startScheduler(); countdownTimer = setInterval(()=>{ if(state.paused) return; state.timeLeft--; timeLeftEl.textContent = state.timeLeft; if(state.timeLeft <= 0){ endGame(); } }, 1000); wmLog('Game started'); startBtn.disabled = true; pauseBtn.textContent = 'Pause'; pauseBtn.disabled = false; saveToStorage(); }

            function pauseGame(){ state.paused = !state.paused; pauseBtn.textContent = state.paused ? 'Resume' : 'Pause'; wmLog(state.paused ? 'Paused' : 'Resumed'); }

            function resetGame(){ stopScheduler(); clearInterval(countdownTimer); Object.keys(state.activeMoles).forEach(id => cleanupMole(id)); state.running = false; state.paused = false; state.score = 0; state.misses = 0; state.timeLeft = config.duration; state.activeMoles = {}; scoreEl.textContent = state.score; timeLeftEl.textContent = state.timeLeft; missesEl.textContent = state.misses; pauseBtn.textContent = 'Pause'; startBtn.disabled = false; pauseBtn.disabled = true; wmLog('Game reset'); saveToStorage(); }

            function endGame(){ stopScheduler(); clearInterval(countdownTimer); Object.keys(state.activeMoles).forEach(id => cleanupMole(id)); state.running = false; startBtn.disabled = false; pauseBtn.disabled = true; wmLog(`Game over ‚Äî Score: ${state.score}, Misses: ${state.misses}`); if(state.score > state.highScore){ state.highScore = state.score; highScoreEl.textContent = state.highScore; saveToStorage(); } saveToStorage(); alert(`Time's up! Score: ${state.score}`); }

            // persistence
            function saveToStorage(){ try{ const save = { highScore: state.highScore, totalWhacks: state.totalWhacks, totalMisses: state.totalMisses, molesWhacked: state.molesWhacked }; localStorage.setItem(SAVE_KEY, JSON.stringify(save)); }catch(e){} }
            function loadFromStorage(){ try{ const raw = localStorage.getItem(SAVE_KEY); if(!raw) return; const obj = JSON.parse(raw); state.highScore = obj.highScore || 0; state.totalWhacks = obj.totalWhacks || 0; state.totalMisses = obj.totalMisses || 0; state.molesWhacked = obj.molesWhacked || 0; highScoreEl.textContent = state.highScore; }catch(e){} }

            // UI wiring (named handlers for cleanup)
            const onStart = ()=> startGame();
            const onPause = ()=> pauseGame();
            const onReset = ()=> resetGame();
            const onAddMole = ()=> spawnMole();

            startBtn.addEventListener('click', onStart);
            pauseBtn.addEventListener('click', onPause);
            resetBtn.addEventListener('click', onReset);
            addMoleBtn.addEventListener('click', onAddMole);
            document.addEventListener('keydown', onKeyDown);

            // init
            loadFromStorage(); buildBoard(); pauseBtn.disabled = true;
            // periodic save
            const saveInterval = setInterval(saveToStorage, 5000);

            // expose debug
            window._whackamole = { state, config, spawnMole, startGame, resetGame };

            // cleanup when modal closes
            activeGameCleanup = function(){ try{ stopScheduler(); clearInterval(countdownTimer); clearInterval(saveInterval); // remove hole listeners
                    holes.forEach(h => { try{ h.hole.removeEventListener('pointerdown', onHolePointerDown); }catch(e){} });
                    startBtn.removeEventListener('click', onStart);
                    pauseBtn.removeEventListener('click', onPause);
                    resetBtn.removeEventListener('click', onReset);
                    addMoleBtn.removeEventListener('click', onAddMole);
                    document.removeEventListener('keydown', onKeyDown);
                }catch(e){ console.error('wam cleanup', e); } activeGameCleanup = null; };
        }

        closeBtn.addEventListener('click', () => {
            modal.style.display = 'none';
            if (snakeGameLoop) {
                clearTimeout(snakeGameLoop);
            }
            if (pongGameLoop) {
                cancelAnimationFrame(pongGameLoop);
            }
            if (minesweeperInterval) {
                clearInterval(minesweeperInterval);
                minesweeperInterval = null;
            }
            if (typeof activeGameCleanup === 'function') {
                try { activeGameCleanup(); } catch (e) { console.error('cleanup failed', e); }
            }
        });

        // Console log for arcade vibe
        console.log('%cWelcome to the Arcade!', 'color: #ff00ff; font-size: 20px; text-shadow: 2px 2px #000;');
    </script>
</body>
</html>
